---
phase: 03-movie-tv-request
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - custom_components/requestarr/const.py
  - custom_components/requestarr/api.py
  - custom_components/requestarr/websocket.py
autonomous: true
requirements: [REQT-01, REQT-02, REQT-04]

must_haves:
  truths:
    - "A movie can be added to Radarr by sending a requestarr/request_movie WebSocket command with tmdb_id, title, title_slug"
    - "A TV series can be added to Sonarr by sending a requestarr/request_series WebSocket command with tvdb_id, title, title_slug, seasons"
    - "Requests use the quality profile and root folder stored in config — not hardcoded values"
    - "Duplicate movie/series requests return success=false with error_code=already_exists (not a JS promise rejection)"
    - "Search results include title_slug, has_file (movies only), and seasons (TV only) so the card can submit request payloads"
  artifacts:
    - path: "custom_components/requestarr/const.py"
      provides: "WS_TYPE_REQUEST_MOVIE and WS_TYPE_REQUEST_TV constants"
      contains: "WS_TYPE_REQUEST_MOVIE"
    - path: "custom_components/requestarr/api.py"
      provides: "ArrClient.async_request_movie and ArrClient.async_request_series methods"
      exports: ["async_request_movie", "async_request_series"]
    - path: "custom_components/requestarr/websocket.py"
      provides: "websocket_request_movie and websocket_request_series handlers registered with HA"
      exports: ["websocket_request_movie", "websocket_request_series"]
  key_links:
    - from: "custom_components/requestarr/websocket.py"
      to: "custom_components/requestarr/api.py"
      via: "coordinator.get_client(SERVICE_RADARR).async_request_movie(...)"
      pattern: "async_request_movie"
    - from: "custom_components/requestarr/websocket.py"
      to: "config entry data"
      via: "_get_config_data(hass)"
      pattern: "CONF_RADARR_QUALITY_PROFILE_ID|CONF_RADARR_ROOT_FOLDER"
    - from: "custom_components/requestarr/websocket.py"
      to: "HA websocket_api"
      via: "async_setup_websocket registration"
      pattern: "async_register_command.*request_movie|async_register_command.*request_series"
---

<objective>
Add two new WebSocket commands — `requestarr/request_movie` and `requestarr/request_series` — that POST to Radarr and Sonarr respectively. Also extend the Phase 2 result normalizers to include the additional fields the card needs to submit requests (`title_slug`, `has_file`, `seasons`).

Purpose: This is the backend half of Phase 3. The card (Plan 03-02) depends on these commands existing and returning structured success/failure results.
Output: Two new WS handlers registered in HA; ArrClient extended with two POST methods; normalizers emitting `title_slug`, `has_file`, `seasons`.
</objective>

<execution_context>
@/home/dab/.claude/get-shit-done/workflows/execute-plan.md
@/home/dab/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-movie-tv-request/03-RESEARCH.md

<interfaces>
<!-- Existing code the executor extends. No codebase exploration needed. -->

From custom_components/requestarr/api.py (current):
```python
class CannotConnectError(Exception): ...
class InvalidAuthError(Exception): ...
class ServerError(Exception): ...

class ArrClient:
    def __init__(self, base_url, api_key, service_type, session, verify_ssl=True, timeout=DEFAULT_TIMEOUT): ...
    async def _request(self, method: str, endpoint: str, **kwargs) -> Any: ...
    # _request raises CannotConnectError, InvalidAuthError, ServerError
    # For POST: await self._request("POST", "/movie", json=payload)
    # HTTP 400 from Radarr add endpoint → ServerError (status 400 means duplicate)
    async def async_search(self, query: str) -> list[dict]: ...
    async def async_get_library_count(self) -> int: ...
```

From custom_components/requestarr/const.py (current):
```python
DOMAIN = "requestarr"
SERVICE_RADARR = "radarr"
SERVICE_SONARR = "sonarr"
SERVICE_LIDARR = "lidarr"
CONF_RADARR_QUALITY_PROFILE_ID = "radarr_quality_profile_id"
CONF_RADARR_ROOT_FOLDER = "radarr_root_folder"
CONF_RADARR_PROFILES = "radarr_profiles"
CONF_SONARR_QUALITY_PROFILE_ID = "sonarr_quality_profile_id"
CONF_SONARR_ROOT_FOLDER = "sonarr_root_folder"
CONF_SONARR_PROFILES = "sonarr_profiles"
WS_TYPE_SEARCH_MOVIES = f"{DOMAIN}/search_movies"
WS_TYPE_SEARCH_TV = f"{DOMAIN}/search_tv"
WS_TYPE_SEARCH_MUSIC = f"{DOMAIN}/search_music"
MAX_SEARCH_RESULTS = 20
```

From custom_components/requestarr/websocket.py (current):
```python
def _get_coordinator(hass): ...  # returns coordinator or None
def _get_config_data(hass) -> dict: ...  # returns entry.data as dict
def _resolve_profile_name(profiles, profile_id) -> str: ...

def _normalize_movie_result(item, config_data) -> dict:
    # Currently returns: title, year, overview, poster_url, in_library, arr_id,
    #                    tmdb_id, quality_profile, root_folder
    # MISSING (needs adding): title_slug, has_file

def _normalize_tv_result(item, config_data) -> dict:
    # Currently returns: title, year, overview, poster_url, in_library, arr_id,
    #                    tvdb_id, quality_profile, root_folder
    # MISSING (needs adding): title_slug, seasons, has_file (always False for TV)

async def _handle_search(hass, connection, msg, service_type, normalize_fn): ...

@websocket_api.async_response
async def websocket_search_movies(hass, connection, msg): ...
# ... search_tv, search_music

@callback
def async_setup_websocket(hass): ...
# Currently registers: websocket_get_data, search_movies, search_tv, search_music
```

Radarr lookup result fields relevant to this plan:
- `titleSlug` — string like "interstellar-157336"
- `hasFile` — bool, True if movie file exists on disk
- `tmdbId` — int

Sonarr lookup result fields relevant to this plan:
- `titleSlug` — string
- `tvdbId` — int
- `seasons` — list of {seasonNumber: int, monitored: bool, statistics: {...}}
  Note: statistics are always 0 in lookup results (Sonarr issue #4942)
  has_file for TV: always False (statistics unreliable in lookup)
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add request constants and extend normalizers with request fields</name>
  <files>
    custom_components/requestarr/const.py
    custom_components/requestarr/websocket.py
  </files>
  <action>
**const.py** — Add two new WebSocket type constants after the existing search constants:
```python
WS_TYPE_REQUEST_MOVIE = f"{DOMAIN}/request_movie"
WS_TYPE_REQUEST_TV = f"{DOMAIN}/request_series"
```

**websocket.py** — Update the two normalizer functions to include the fields needed for request payloads:

`_normalize_movie_result`: Add these two keys to the returned dict:
```python
"title_slug": item.get("titleSlug", ""),
"has_file": item.get("hasFile", False),
```

`_normalize_tv_result`: Add these three keys to the returned dict:
```python
"title_slug": item.get("titleSlug", ""),
"has_file": False,   # Sonarr lookup statistics always 0 (issue #4942); card shows Monitored for all in-library TV
"seasons": item.get("seasons", []),   # pass raw seasons list through; card sends it back in request payload
```

Also add the two new constants to the import from `.const` at the top of websocket.py:
```python
WS_TYPE_REQUEST_MOVIE,
WS_TYPE_REQUEST_TV,
```
  </action>
  <verify>
    <automated>cd /home/dab/Projects/ha-requestarr && python -c "from custom_components.requestarr.const import WS_TYPE_REQUEST_MOVIE, WS_TYPE_REQUEST_TV; print(WS_TYPE_REQUEST_MOVIE, WS_TYPE_REQUEST_TV)"</automated>
  </verify>
  <done>
    - `requestarr/request_movie` and `requestarr/request_series` are importable from const.py
    - `_normalize_movie_result` returns `title_slug` and `has_file` keys
    - `_normalize_tv_result` returns `title_slug`, `has_file` (always False), and `seasons` keys
  </done>
</task>

<task type="auto">
  <name>Task 2: Add async_request_movie and async_request_series to ArrClient</name>
  <files>
    custom_components/requestarr/api.py
  </files>
  <action>
Add two new async methods to `ArrClient` after `async_search`. Both use the existing `_request` method with `method="POST"`.

```python
async def async_request_movie(
    self,
    tmdb_id: int,
    title: str,
    title_slug: str,
    quality_profile_id: int,
    root_folder_path: str,
) -> dict[str, Any]:
    """Add a movie to Radarr.

    Raises:
        CannotConnectError: Cannot reach Radarr.
        InvalidAuthError: API key rejected.
        ServerError: Non-auth HTTP error. HTTP 400 from Radarr add endpoint means duplicate.
    """
    payload = {
        "tmdbId": tmdb_id,
        "title": title,
        "titleSlug": title_slug,
        "qualityProfileId": int(quality_profile_id),
        "rootFolderPath": root_folder_path,
        "monitored": True,
        "minimumAvailability": "released",
        "addOptions": {"searchForMovie": True},
    }
    return await self._request("POST", "/movie", json=payload)


async def async_request_series(
    self,
    tvdb_id: int,
    title: str,
    title_slug: str,
    quality_profile_id: int,
    root_folder_path: str,
    seasons: list[dict[str, Any]],
) -> dict[str, Any]:
    """Add a series to Sonarr.

    Raises:
        CannotConnectError: Cannot reach Sonarr.
        InvalidAuthError: API key rejected.
        ServerError: Non-auth HTTP error. HTTP 400 from Sonarr add endpoint means duplicate.
    """
    payload = {
        "tvdbId": tvdb_id,
        "title": title,
        "titleSlug": title_slug,
        "qualityProfileId": int(quality_profile_id),
        "rootFolderPath": root_folder_path,
        "monitored": True,
        "seasonFolder": True,
        "seriesType": "standard",
        "seasons": [
            {"seasonNumber": s.get("seasonNumber", 0), "monitored": True}
            for s in seasons
        ],
        "addOptions": {
            "searchForMissingEpisodes": True,
            "monitor": "all",
        },
    }
    return await self._request("POST", "/series", json=payload)
```

The `int(quality_profile_id)` cast is intentional — config/options flow stores profile IDs as strings from HTML selectors, but Radarr/Sonarr validate as integers and return 422 without the cast.

The `seasons` arg for `async_request_series` passes through the raw seasons list from the lookup response (each item is a dict with at least `seasonNumber`). Only `seasonNumber` is forwarded; `monitored` is forced True so all seasons are monitored immediately. If `seasons` is empty (new show with no TVDB data), send an empty array and let Sonarr's `addOptions.monitor: "all"` default apply.
  </action>
  <verify>
    <automated>cd /home/dab/Projects/ha-requestarr && python -c "from custom_components.requestarr.api import ArrClient; import inspect; src = inspect.getsource(ArrClient.async_request_movie); assert 'tmdbId' in src and 'qualityProfileId' in src and 'int(quality_profile_id)' in src; print('async_request_movie OK'); src2 = inspect.getsource(ArrClient.async_request_series); assert 'tvdbId' in src2 and 'seasonNumber' in src2; print('async_request_series OK')"</automated>
  </verify>
  <done>
    - `ArrClient.async_request_movie` exists, POSTs to `/movie`, includes `tmdbId`, `qualityProfileId` (cast to int), `rootFolderPath`, `minimumAvailability: released`, `addOptions.searchForMovie: True`
    - `ArrClient.async_request_series` exists, POSTs to `/series`, includes `tvdbId`, `seasons` (rebuilt from arg with `monitored: True`), `addOptions.searchForMissingEpisodes: True`, `addOptions.monitor: all`
  </done>
</task>

<task type="auto">
  <name>Task 3: Add request WebSocket handlers and register them</name>
  <files>
    custom_components/requestarr/websocket.py
  </files>
  <action>
Add two new WebSocket handler functions following the exact pattern of `websocket_search_movies`. Place them after the existing search handlers and before the `async_setup_websocket` registration function.

**Key design decisions:**
- Use `connection.send_result(msg["id"], {"success": False, "error_code": ..., "message": ...})` for ALL error cases — never `send_error`. This ensures the JS `sendMessagePromise` resolves (not rejects) and the card can display inline error messages.
- HTTP 400 from Radarr/Sonarr add endpoint reliably indicates "already added". Map `ServerError` with status-400-like errors to `error_code: "already_exists"`.
- All other `ServerError` (5xx, other 4xx) → `error_code: "service_unavailable"`.
- `CannotConnectError` and `InvalidAuthError` → `error_code: "service_unavailable"`.

**Handler for request_movie:**
```python
@websocket_api.websocket_command(
    {
        vol.Required("type"): WS_TYPE_REQUEST_MOVIE,
        vol.Required("tmdb_id"): int,
        vol.Required("title"): str,
        vol.Required("title_slug"): str,
    }
)
@websocket_api.async_response
async def websocket_request_movie(
    hass: HomeAssistant,
    connection: websocket_api.ActiveConnection,
    msg: dict[str, Any],
) -> None:
    """Handle movie request via Radarr POST."""
    coordinator = _get_coordinator(hass)
    if coordinator is None:
        connection.send_result(
            msg["id"],
            {"success": False, "error_code": "not_configured", "message": "Requestarr not configured"},
        )
        return

    client = coordinator.get_client(SERVICE_RADARR)
    if client is None:
        connection.send_result(
            msg["id"],
            {"success": False, "error_code": "service_not_configured", "message": "Radarr is not configured"},
        )
        return

    config_data = _get_config_data(hass)
    quality_profile_id = config_data.get(CONF_RADARR_QUALITY_PROFILE_ID)
    root_folder = config_data.get(CONF_RADARR_ROOT_FOLDER, "")

    try:
        await client.async_request_movie(
            tmdb_id=msg["tmdb_id"],
            title=msg["title"],
            title_slug=msg["title_slug"],
            quality_profile_id=quality_profile_id,
            root_folder_path=root_folder,
        )
        connection.send_result(msg["id"], {"success": True})
    except ServerError as err:
        err_str = str(err)
        # Radarr 400 on the add endpoint means the movie is already in the library
        if "400" in err_str:
            connection.send_result(
                msg["id"],
                {"success": False, "error_code": "already_exists", "message": "This movie is already in Radarr"},
            )
        else:
            _LOGGER.warning("Movie request failed: %s", err)
            connection.send_result(
                msg["id"],
                {"success": False, "error_code": "service_unavailable", "message": str(err)},
            )
    except (CannotConnectError, InvalidAuthError) as err:
        _LOGGER.warning("Movie request failed: %s", err)
        connection.send_result(
            msg["id"],
            {"success": False, "error_code": "service_unavailable", "message": str(err)},
        )
```

**Handler for request_series** (same structure, different service/fields):
```python
@websocket_api.websocket_command(
    {
        vol.Required("type"): WS_TYPE_REQUEST_TV,
        vol.Required("tvdb_id"): int,
        vol.Required("title"): str,
        vol.Required("title_slug"): str,
        vol.Required("seasons"): list,
    }
)
@websocket_api.async_response
async def websocket_request_series(
    hass: HomeAssistant,
    connection: websocket_api.ActiveConnection,
    msg: dict[str, Any],
) -> None:
    """Handle TV series request via Sonarr POST."""
    coordinator = _get_coordinator(hass)
    if coordinator is None:
        connection.send_result(
            msg["id"],
            {"success": False, "error_code": "not_configured", "message": "Requestarr not configured"},
        )
        return

    client = coordinator.get_client(SERVICE_SONARR)
    if client is None:
        connection.send_result(
            msg["id"],
            {"success": False, "error_code": "service_not_configured", "message": "Sonarr is not configured"},
        )
        return

    config_data = _get_config_data(hass)
    quality_profile_id = config_data.get(CONF_SONARR_QUALITY_PROFILE_ID)
    root_folder = config_data.get(CONF_SONARR_ROOT_FOLDER, "")

    try:
        await client.async_request_series(
            tvdb_id=msg["tvdb_id"],
            title=msg["title"],
            title_slug=msg["title_slug"],
            quality_profile_id=quality_profile_id,
            root_folder_path=root_folder,
            seasons=msg["seasons"],
        )
        connection.send_result(msg["id"], {"success": True})
    except ServerError as err:
        err_str = str(err)
        # Sonarr 400 on the add endpoint means the series is already in the library
        if "400" in err_str:
            connection.send_result(
                msg["id"],
                {"success": False, "error_code": "already_exists", "message": "This series is already in Sonarr"},
            )
        else:
            _LOGGER.warning("Series request failed: %s", err)
            connection.send_result(
                msg["id"],
                {"success": False, "error_code": "service_unavailable", "message": str(err)},
            )
    except (CannotConnectError, InvalidAuthError) as err:
        _LOGGER.warning("Series request failed: %s", err)
        connection.send_result(
            msg["id"],
            {"success": False, "error_code": "service_unavailable", "message": str(err)},
        )
```

**Update `async_setup_websocket`** to register the two new handlers:
```python
websocket_api.async_register_command(hass, websocket_request_movie)
websocket_api.async_register_command(hass, websocket_request_series)
```

Add these two lines after the existing `async_register_command` calls for search handlers.
  </action>
  <verify>
    <automated>cd /home/dab/Projects/ha-requestarr && python -c "
import ast, sys
with open('custom_components/requestarr/websocket.py') as f:
    src = f.read()
tree = ast.parse(src)
fns = [n.name for n in ast.walk(tree) if isinstance(n, ast.AsyncFunctionDef)]
assert 'websocket_request_movie' in fns, 'Missing websocket_request_movie'
assert 'websocket_request_series' in fns, 'Missing websocket_request_series'
assert 'websocket_request_movie' in src, 'Not registered?'
assert 'websocket_request_series' in src, 'Not registered?'
assert 'already_exists' in src, 'Missing already_exists error code'
assert 'send_result' in src, 'Must use send_result not send_error for request failures'
print('All assertions passed')
"</automated>
  </verify>
  <done>
    - `websocket_request_movie` and `websocket_request_series` functions exist in websocket.py
    - Both are registered in `async_setup_websocket`
    - All error paths use `send_result` with structured `{success, error_code, message}` (never `send_error`)
    - HTTP 400 from arr service maps to `error_code: "already_exists"`
    - Schema validates: `tmdb_id` (int), `title` (str), `title_slug` (str) for movies; adds `tvdb_id` (int) and `seasons` (list) for series
  </done>
</task>

</tasks>

<verification>
Run the following to confirm the full backend is wired correctly:

```bash
cd /home/dab/Projects/ha-requestarr && python -c "
from custom_components.requestarr.const import WS_TYPE_REQUEST_MOVIE, WS_TYPE_REQUEST_TV
from custom_components.requestarr.api import ArrClient
from custom_components.requestarr.websocket import websocket_request_movie, websocket_request_series, async_setup_websocket
import inspect

# Verify constants
assert WS_TYPE_REQUEST_MOVIE == 'requestarr/request_movie'
assert WS_TYPE_REQUEST_TV == 'requestarr/request_series'

# Verify ArrClient methods
assert hasattr(ArrClient, 'async_request_movie')
assert hasattr(ArrClient, 'async_request_series')

# Verify normalizers include new fields
src = inspect.getsource(__import__('custom_components.requestarr.websocket', fromlist=['websocket']))
assert 'title_slug' in src
assert 'has_file' in src
assert '\"seasons\"' in src or \"'seasons'\" in src

print('Phase 3 Plan 01: ALL CHECKS PASSED')
"
```
</verification>

<success_criteria>
1. `requestarr/request_movie` WebSocket command registered in HA — validates `tmdb_id` (int), `title` (str), `title_slug` (str)
2. `requestarr/request_series` WebSocket command registered in HA — validates `tvdb_id` (int), `title` (str), `title_slug` (str), `seasons` (list)
3. Both commands POST to the correct arr service using quality_profile_id and root_folder from config entry data
4. All error responses use `send_result` (not `send_error`) with `{success: false, error_code, message}` structure
5. HTTP 400 from arr add endpoint maps to `error_code: "already_exists"`
6. Search result normalizers emit `title_slug` and `has_file` (movies), `title_slug`, `has_file=False`, `seasons` (TV)
</success_criteria>

<output>
After completion, create `.planning/phases/03-movie-tv-request/03-01-SUMMARY.md` following the GSD summary template.
</output>
