---
phase: 03-movie-tv-request
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - custom_components/requestarr/frontend/requestarr-card.js
autonomous: false
requirements: [CARD-01, CARD-02, CARD-03, CARD-04]

must_haves:
  truths:
    - "Card shows Movies and TV tabs; clicking a tab immediately re-searches the same query in the other service"
    - "Typing fewer than 2 characters shows no results (empty state); typing 2+ characters triggers search after 300ms debounce"
    - "Each result row shows a 2:3 poster thumbnail (60x90px), title, year, and a status badge OR Request button"
    - "Tapping Request opens an inline confirm dialog showing title, quality profile, and root folder; Cancel dismisses it"
    - "Confirming the dialog sends the request command and changes the button to 'Requested' (disabled, yellow) on success"
    - "Request failure shows inline error text beneath the result row; button resets to 'Request' for retry"
    - "Items already in the arr service show a badge (green Available / blue Monitored) instead of a Request button"
    - "A loading spinner appears near the search box while results are loading; previous results stay visible during the new fetch"
    - "Poster load failure is handled silently (onerror hides the img tag, placeholder div shown instead)"
    - "Music tab placeholder is rendered (disabled/greyed tab button) so Phase 4 can activate it without structural changes"
  artifacts:
    - path: "custom_components/requestarr/frontend/requestarr-card.js"
      provides: "Full RequestarrCard LitElement rewrite with tabs, search, results, confirm dialog"
      min_lines: 200
      contains: "requestarr/search_movies"
  key_links:
    - from: "requestarr-card.js _doSearch()"
      to: "requestarr/search_movies or requestarr/search_tv WS command"
      via: "this.hass.connection.sendMessagePromise({type, query})"
      pattern: "sendMessagePromise"
    - from: "requestarr-card.js _doRequest()"
      to: "requestarr/request_movie or requestarr/request_series WS command"
      via: "this.hass.connection.sendMessagePromise({type, tmdb_id|tvdb_id, title, title_slug, seasons})"
      pattern: "request_movie|request_series"
    - from: "_getItemState(item)"
      to: "item.in_library + item.has_file"
      via: "conditional logic mapping to available/monitored/requested/not_in_library"
      pattern: "in_library|has_file"
---

<objective>
Rewrite `requestarr-card.js` from the scaffold stub into a fully functional Lovelace card with:
- Movies / TV tabs (Music as disabled placeholder for Phase 4)
- Shared search box with 2-char minimum and 300ms debounce
- Vertical list results with 2:3 poster thumbnails and status badges
- Inline confirm dialog before submitting requests
- Full status state system (Available / Monitored / Requested / Request button)

Purpose: This is the user-facing half of Phase 3. It depends on Plan 03-01 for the `request_movie` and `request_series` WS commands.
Output: A complete `requestarr-card.js` users can add to their Lovelace dashboard to search movies/TV and submit requests.
</objective>

<execution_context>
@/home/dab/.claude/get-shit-done/workflows/execute-plan.md
@/home/dab/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-movie-tv-request/03-CONTEXT.md
@.planning/phases/03-movie-tv-request/03-RESEARCH.md
@.planning/phases/03-movie-tv-request/03-01-SUMMARY.md

<interfaces>
<!-- WebSocket commands available from Plan 03-01 -->

Search commands (from Phase 2, already working):
  type: "requestarr/search_movies"  — payload: {type, query: string}
  type: "requestarr/search_tv"      — payload: {type, query: string}
  Response: {results: Array<MovieResult | TvResult>}

  MovieResult shape (after Plan 03-01 normalizer additions):
  {
    title: string,
    year: number | null,
    poster_url: string | null,
    in_library: boolean,        // true if arr_id > 0
    arr_id: number | null,
    tmdb_id: number | null,
    title_slug: string,         // NEW in Plan 03-01
    has_file: boolean,          // NEW in Plan 03-01 — true if movie file exists
    quality_profile: string,    // profile name from config
    root_folder: string,        // root folder path from config
  }

  TvResult shape (after Plan 03-01 normalizer additions):
  {
    title: string,
    year: number | null,
    poster_url: string | null,
    in_library: boolean,
    arr_id: number | null,
    tvdb_id: number | null,
    title_slug: string,         // NEW in Plan 03-01
    has_file: false,            // always false for TV (Sonarr lookup stats issue #4942)
    seasons: Array<{seasonNumber: number, monitored: boolean, ...}>, // NEW in Plan 03-01
    quality_profile: string,
    root_folder: string,
  }

Request commands (from Plan 03-01):
  type: "requestarr/request_movie"
  payload: {type, tmdb_id: int, title: string, title_slug: string}
  Response (always resolves, never rejects):
    success case: {success: true}
    error case:   {success: false, error_code: "already_exists"|"service_unavailable"|..., message: string}

  type: "requestarr/request_series"
  payload: {type, tvdb_id: int, title: string, title_slug: string, seasons: array}
  Response: same success/error shape as request_movie

LitElement base (from existing card scaffold — do NOT change):
  const LitElement = customElements.get("hui-masonry-view")
    ? Object.getPrototypeOf(customElements.get("hui-masonry-view"))
    : Object.getPrototypeOf(customElements.get("hui-view"));
  const html = LitElement.prototype.html;
  const css = LitElement.prototype.css;

HA CSS variables for status badge colors:
  --success-color   (green  — Available)
  --primary-color   (blue   — Monitored; use as fallback for --info-color)
  --warning-color   (yellow — Requested)
  --primary-text-color, --secondary-text-color, --card-background-color
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite requestarr-card.js with full Movies/TV UI</name>
  <files>
    custom_components/requestarr/frontend/requestarr-card.js
  </files>
  <action>
Replace the entire contents of `requestarr-card.js` with a complete LitElement implementation. The file is a **full rewrite** — do not attempt to preserve any scaffold logic.

**Keep from scaffold (exactly as-is):**
- The LitElement base resolution pattern (lines 1-11)
- `const CARD_VERSION = "0.1.0";` — bump to `"0.3.0"` to reflect Phase 3
- `console.info(...)` banner
- `customElements.define` + `window.customCards.push` at the bottom (keep both)
- `getCardSize()`, `getGridOptions()` — keep existing values
- `static getConfigElement()` / `static getStubConfig()` — simplify: remove entity picker, stub returns `{header: "Requestarr"}`

**Remove from scaffold:**
- All entity-based logic (`config.entity`, `hass.states[entityId]`, etc.)
- `RequestarrCardEditor` complex implementation — replace with minimal stub that renders nothing (Phase 5 adds the real editor)

**New `RequestarrCard` implementation:**

```javascript
// State properties
static get properties() {
    return {
        hass: { type: Object },
        config: { type: Object },
        _activeTab: { type: String },    // 'movies' | 'tv'
        _query: { type: String },
        _results: { type: Array },
        _loading: { type: Boolean },
        _dialogItem: { type: Object },   // item pending confirm, null otherwise
        _requesting: { type: Object },   // { [key]: 'requesting'|'requested'|'error' }
        _requestError: { type: Object }, // { [key]: errorString }
    };
}
```

**Constructor / initialization:**
```javascript
constructor() {
    super();
    this._activeTab = 'movies';
    this._query = '';
    this._results = [];
    this._loading = false;
    this._dialogItem = null;
    this._requesting = {};
    this._requestError = {};
    this._debounceTimer = null;
    this._searchSeq = 0;  // race condition guard: track latest search sequence
}
```

**setConfig:**
```javascript
setConfig(config) {
    if (!config) throw new Error("Invalid configuration");
    this.config = { header: "Requestarr", ...config };
}
```

**Search input handler** (2-char minimum, 300ms debounce):
```javascript
_onSearchInput(e) {
    this._query = e.target.value;
    clearTimeout(this._debounceTimer);
    if (this._query.length < 2) {
        this._results = [];
        return;
    }
    this._debounceTimer = setTimeout(() => this._doSearch(), 300);
}
```

**Tab switch handler** (immediately re-search same query):
```javascript
_switchTab(tab) {
    if (this._activeTab === tab) return;
    this._activeTab = tab;
    this._results = [];   // clear stale results immediately
    if (this._query.length >= 2) {
        clearTimeout(this._debounceTimer);
        this._doSearch();
    }
}
```

**Search execution** (with sequence counter to prevent race condition):
```javascript
async _doSearch() {
    const type = this._activeTab === 'movies'
        ? 'requestarr/search_movies'
        : 'requestarr/search_tv';
    const seq = ++this._searchSeq;
    this._loading = true;
    try {
        const resp = await this.hass.connection.sendMessagePromise({
            type,
            query: this._query,
        });
        if (seq !== this._searchSeq) return;  // stale response, discard
        this._results = resp.results || [];
    } catch (_err) {
        if (seq !== this._searchSeq) return;
        this._results = [];
    } finally {
        if (seq === this._searchSeq) this._loading = false;
    }
}
```

**Item state mapping:**
```javascript
_getItemState(item) {
    const key = String(item.tmdb_id ?? item.tvdb_id);
    const reqState = this._requesting[key];
    if (reqState === 'requested') return 'requested';
    if (!item.in_library) return 'not_in_library';
    if (item.has_file) return 'available';
    return 'monitored';
}
```

**Request submission** (triggered by confirm dialog Confirm button):
```javascript
async _doRequest(item) {
    const key = String(item.tmdb_id ?? item.tvdb_id);
    this._requesting = { ...this._requesting, [key]: 'requesting' };
    this._dialogItem = null;

    const isMovie = this._activeTab === 'movies';
    const payload = isMovie
        ? {
            type: 'requestarr/request_movie',
            tmdb_id: item.tmdb_id,
            title: item.title,
            title_slug: item.title_slug,
          }
        : {
            type: 'requestarr/request_series',
            tvdb_id: item.tvdb_id,
            title: item.title,
            title_slug: item.title_slug,
            seasons: item.seasons || [],
          };

    try {
        const resp = await this.hass.connection.sendMessagePromise(payload);
        if (resp.success) {
            this._requesting = { ...this._requesting, [key]: 'requested' };
        } else {
            this._requesting = { ...this._requesting, [key]: 'error' };
            this._requestError = { ...this._requestError, [key]: resp.message || 'Request failed' };
        }
    } catch (_err) {
        this._requesting = { ...this._requesting, [key]: 'error' };
        this._requestError = { ...this._requestError, [key]: 'Connection error' };
    }
}
```

**`render()` method** — overall card structure:
```javascript
render() {
    if (!this.hass || !this.config) {
        return html`<ha-card><div class="loading"><ha-spinner size="small"></ha-spinner></div></ha-card>`;
    }
    return html`
        <ha-card header="${this.config.header || ''}">
            <div class="card-content">
                ${this._renderTabs()}
                ${this._renderSearch()}
                ${this._renderResults()}
            </div>
            ${this._renderDialog()}
        </ha-card>
    `;
}
```

**`_renderTabs()`** — Movies / TV tabs, Music as disabled placeholder:
```javascript
_renderTabs() {
    return html`
        <div class="tabs">
            <button class="tab ${this._activeTab === 'movies' ? 'active' : ''}"
                @click="${() => this._switchTab('movies')}">Movies</button>
            <button class="tab ${this._activeTab === 'tv' ? 'active' : ''}"
                @click="${() => this._switchTab('tv')}">TV</button>
            <button class="tab disabled" disabled title="Coming in Phase 4">Music</button>
        </div>
    `;
}
```

**`_renderSearch()`** — input + spinner:
```javascript
_renderSearch() {
    return html`
        <div class="search-wrap">
            <input
                class="search-input"
                type="search"
                placeholder="Search..."
                .value="${this._query}"
                @input="${this._onSearchInput}"
            />
            ${this._loading ? html`<ha-spinner size="small" class="search-spinner"></ha-spinner>` : ''}
        </div>
    `;
}
```

**`_renderResults()`** — empty state, no-query state, or result list:
```javascript
_renderResults() {
    if (this._query.length < 2) return html``;
    if (!this._loading && this._results.length === 0) {
        return html`<div class="empty">No results for "${this._query}"</div>`;
    }
    return html`
        <div class="results">
            ${this._results.map(item => this._renderResultRow(item))}
        </div>
    `;
}
```

**`_renderResultRow(item)`** — poster + info + status/button:
```javascript
_renderResultRow(item) {
    const state = this._getItemState(item);
    const key = String(item.tmdb_id ?? item.tvdb_id);
    const reqErr = this._requestError[key];
    return html`
        <div class="result-row">
            <div class="poster-wrap">
                ${item.poster_url
                    ? html`<img class="poster" src="${item.poster_url}" alt=""
                            @error="${(e) => { e.target.style.display = 'none'; }}">`
                    : ''}
                <div class="poster-placeholder"></div>
            </div>
            <div class="result-info">
                <span class="result-title">${item.title}</span>
                ${item.year ? html`<span class="result-year">${item.year}</span>` : ''}
                ${this._renderStatus(state, item)}
                ${reqErr ? html`<span class="req-error">${reqErr}</span>` : ''}
            </div>
        </div>
    `;
}
```

Note on poster placeholder: render `<div class="poster-placeholder">` unconditionally behind the `<img>`. When the img loads successfully it covers the placeholder. When img fails (@error hides it), the placeholder is visible. This avoids a layout shift.

**`_renderStatus(state, item)`** — badge or request button:
```javascript
_renderStatus(state, item) {
    const key = String(item.tmdb_id ?? item.tvdb_id);
    const isRequesting = this._requesting[key] === 'requesting';
    switch (state) {
        case 'available':
            return html`<span class="badge badge-available">Available</span>`;
        case 'monitored':
            return html`<span class="badge badge-monitored">Monitored</span>`;
        case 'requested':
            return html`<span class="badge badge-requested">Requested</span>`;
        case 'not_in_library':
        default:
            return html`<button class="req-btn"
                ?disabled="${isRequesting}"
                @click="${() => { this._dialogItem = item; }}">
                ${isRequesting ? 'Requesting…' : 'Request'}
            </button>`;
    }
}
```

**`_renderDialog()`** — inline confirm dialog:
```javascript
_renderDialog() {
    if (!this._dialogItem) return html``;
    const item = this._dialogItem;
    const key = String(item.tmdb_id ?? item.tvdb_id);
    const isRequesting = this._requesting[key] === 'requesting';
    return html`
        <div class="dialog-overlay" @click="${() => { this._dialogItem = null; }}">
            <div class="dialog" @click="${(e) => e.stopPropagation()}">
                <div class="dialog-title">${item.title}</div>
                <div class="dialog-meta">
                    <div>Profile: ${item.quality_profile || '—'}</div>
                    <div>Folder: ${item.root_folder || '—'}</div>
                </div>
                <div class="dialog-actions">
                    <button class="btn-cancel"
                        @click="${() => { this._dialogItem = null; }}">Cancel</button>
                    <button class="btn-confirm"
                        ?disabled="${isRequesting}"
                        @click="${() => this._doRequest(item)}">
                        ${isRequesting ? 'Requesting…' : 'Confirm'}
                    </button>
                </div>
            </div>
        </div>
    `;
}
```

**CSS** (inside `static get styles()` using the `css` tagged template literal — HA CSS variables for colors):
```css
:host { display: block; }
.card-content { padding: 0 16px 16px; }

/* Tabs */
.tabs { display: flex; gap: 4px; padding: 12px 0 8px; border-bottom: 1px solid var(--divider-color); margin-bottom: 12px; }
.tab { background: none; border: none; padding: 6px 14px; border-radius: 16px; cursor: pointer; font-size: 0.875rem; font-weight: 500; color: var(--secondary-text-color); transition: background 0.15s, color 0.15s; }
.tab.active { background: var(--primary-color); color: white; }
.tab:hover:not(.active):not(.disabled) { background: var(--secondary-background-color); }
.tab.disabled { opacity: 0.4; cursor: default; }

/* Search */
.search-wrap { position: relative; margin-bottom: 12px; }
.search-input { width: 100%; box-sizing: border-box; padding: 8px 12px; border: 1px solid var(--divider-color); border-radius: 8px; background: var(--secondary-background-color); color: var(--primary-text-color); font-size: 1rem; outline: none; }
.search-input:focus { border-color: var(--primary-color); }
.search-spinner { position: absolute; right: 10px; top: 50%; transform: translateY(-50%); }

/* Results */
.results { display: flex; flex-direction: column; gap: 8px; }
.empty { color: var(--secondary-text-color); padding: 16px 0; text-align: center; }
.result-row { display: flex; gap: 12px; align-items: flex-start; padding: 8px 0; border-bottom: 1px solid var(--divider-color); }
.result-row:last-child { border-bottom: none; }

/* Poster */
.poster-wrap { position: relative; flex-shrink: 0; width: 60px; height: 90px; border-radius: 4px; overflow: hidden; background: var(--secondary-background-color); }
.poster { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; }
.poster-placeholder { position: absolute; inset: 0; }

/* Result info */
.result-info { flex: 1; display: flex; flex-direction: column; gap: 4px; padding-top: 2px; }
.result-title { font-weight: 500; color: var(--primary-text-color); font-size: 0.9rem; line-height: 1.3; }
.result-year { color: var(--secondary-text-color); font-size: 0.8rem; }
.req-error { color: var(--error-color, #f44336); font-size: 0.8rem; }

/* Status badges */
.badge { display: inline-block; padding: 2px 8px; border-radius: 10px; font-size: 0.75rem; font-weight: 600; color: white; align-self: flex-start; }
.badge-available { background: var(--success-color, #4CAF50); }
.badge-monitored  { background: var(--info-color, var(--primary-color, #2196F3)); }
.badge-requested  { background: var(--warning-color, #FF9800); }

/* Request button */
.req-btn { padding: 4px 12px; border: none; border-radius: 6px; background: var(--primary-color); color: white; cursor: pointer; font-size: 0.8rem; font-weight: 500; align-self: flex-start; }
.req-btn:disabled { opacity: 0.6; cursor: default; }
.req-btn:hover:not(:disabled) { filter: brightness(1.1); }

/* Confirm dialog */
.dialog-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 999; }
.dialog { background: var(--card-background-color); border-radius: 12px; padding: 20px; min-width: 280px; max-width: 360px; box-shadow: 0 8px 32px rgba(0,0,0,0.3); }
.dialog-title { font-size: 1rem; font-weight: 600; color: var(--primary-text-color); margin-bottom: 12px; }
.dialog-meta { color: var(--secondary-text-color); font-size: 0.85rem; margin-bottom: 16px; display: flex; flex-direction: column; gap: 4px; }
.dialog-actions { display: flex; gap: 8px; justify-content: flex-end; }
.btn-cancel { padding: 8px 16px; border: 1px solid var(--divider-color); border-radius: 6px; background: none; color: var(--primary-text-color); cursor: pointer; }
.btn-confirm { padding: 8px 16px; border: none; border-radius: 6px; background: var(--primary-color); color: white; cursor: pointer; font-weight: 500; }
.btn-confirm:disabled { opacity: 0.6; cursor: default; }

/* Loading state (initial card load) */
.loading { display: flex; justify-content: center; padding: 32px 16px; }
```

**`RequestarrCardEditor`** — replace with minimal stub (Phase 5 implements the full editor):
```javascript
class RequestarrCardEditor extends LitElement {
    static get properties() { return { hass: {}, config: {} }; }
    setConfig(config) { this.config = config; }
    render() { return html``; }
}
```

The `static getConfigElement()` on `RequestarrCard` should still return `document.createElement("requestarr-card-editor")` — the editor just shows nothing until Phase 5.

**Bump `CARD_VERSION`** to `"0.3.0"`.

**Anti-patterns to avoid (per research):**
- Do NOT use `window.confirm()` — blocked in shadow DOM contexts. Use the inline dialog pattern above.
- Do NOT call `send_error` on the backend for request failures — already handled in Plan 03-01, the WS response always resolves.
- Do NOT mutate `_requesting` or `_requestError` in-place — always spread to a new object so LitElement detects the reference change and re-renders.
- Do NOT store per-tab results arrays — one `_results` + re-search on tab switch.
  </action>
  <verify>
    <automated>cd /home/dab/Projects/ha-requestarr && node --input-type=module <<'EOF'
import { readFileSync } from 'fs';
const src = readFileSync('custom_components/requestarr/frontend/requestarr-card.js', 'utf8');

const checks = [
    ['WS search_movies', src.includes('requestarr/search_movies')],
    ['WS search_tv', src.includes('requestarr/search_tv')],
    ['WS request_movie', src.includes('requestarr/request_movie')],
    ['WS request_series', src.includes('requestarr/request_series')],
    ['sendMessagePromise', src.includes('sendMessagePromise')],
    ['300ms debounce', src.includes('300')],
    ['2-char minimum', src.includes('length < 2') || src.includes('length >= 2')],
    ['_searchSeq race guard', src.includes('_searchSeq')],
    ['LitElement spread mutation', src.includes('{ ...this._requesting')],
    ['dialog-overlay', src.includes('dialog-overlay')],
    ['badge-available', src.includes('badge-available')],
    ['badge-monitored', src.includes('badge-monitored')],
    ['badge-requested', src.includes('badge-requested')],
    ['has_file', src.includes('has_file')],
    ['in_library', src.includes('in_library')],
    ['Music tab placeholder', src.includes('disabled') && src.includes('Music')],
    ['poster 60px', src.includes('60px')],
    ['version 0.3.0', src.includes('0.3.0')],
];

let failed = 0;
for (const [name, result] of checks) {
    if (!result) { console.error('FAIL:', name); failed++; }
    else console.log('OK:', name);
}
if (failed > 0) process.exit(1);
console.log('\nAll checks passed');
EOF</automated>
  </verify>
  <done>
    - Card renders Movies and TV tabs; Music tab is present but disabled
    - Search input with 300ms debounce and 2-char minimum implemented
    - Result rows: 60x90 poster on left, title + year + status/button on right
    - Four status states: Available (green), Monitored (blue), Requested (yellow), Request button
    - Confirm dialog opens on Request tap, shows title + quality_profile + root_folder, Cancel/Confirm buttons
    - On confirm success: button transitions to "Requested" disabled badge
    - On confirm failure: inline error text shown, button resets to "Request"
    - Search race condition handled via _searchSeq counter
    - LitElement object mutation handled via spread pattern
    - `CARD_VERSION` is `"0.3.0"`
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Requestarr card with Movies/TV tabs, debounced search, poster results, confirm dialog, and four status states. Backend request commands from Plan 03-01.
  </what-built>
  <how-to-verify>
1. Add `requestarr-card` to a Lovelace dashboard (type: custom:requestarr-card).
2. Verify the card shows "Movies" (active) and "TV" tabs, plus a greyed-out "Music" tab.
3. Type 1 character in the search box — verify no search fires and no results show.
4. Type 2+ characters — verify a search fires after ~300ms and results appear with poster thumbnails, title, year.
5. Switch to the "TV" tab — verify the same query immediately re-searches in Sonarr and results update.
6. For a result not in the library, click "Request" — verify the confirm dialog opens showing the title, quality profile name, and root folder path.
7. Click Cancel — verify dialog closes and button resets to "Request".
8. Click Request again, then Confirm — verify the button changes to "Requesting…" during the request, then to a yellow "Requested" badge on success.
9. Find a result already in Radarr (in_library=true, has_file=true) — verify it shows a green "Available" badge (no Request button).
10. Find a result monitored but not downloaded — verify blue "Monitored" badge.
11. Verify that typing in search while previous results are loading shows the spinner but keeps the old results visible.
  </how-to-verify>
  <resume-signal>Type "approved" if the card behaves correctly, or describe any issues found.</resume-signal>
</task>

</tasks>

<verification>
Static checks (automated):
```bash
cd /home/dab/Projects/ha-requestarr && node --input-type=module <<'EOF'
import { readFileSync } from 'fs';
const src = readFileSync('custom_components/requestarr/frontend/requestarr-card.js', 'utf8');
const required = [
    'requestarr/search_movies', 'requestarr/search_tv',
    'requestarr/request_movie', 'requestarr/request_series',
    'sendMessagePromise', '_searchSeq', '{ ...this._requesting',
    'dialog-overlay', 'badge-available', 'badge-monitored', 'badge-requested',
    'has_file', 'in_library', '300', '0.3.0',
];
const missing = required.filter(s => !src.includes(s));
if (missing.length) { console.error('Missing:', missing); process.exit(1); }
console.log('All static checks passed');
EOF
```

Functional verification: via the checkpoint task above (human-verify gate).
</verification>

<success_criteria>
1. Card renders Movies / TV tabs; Music tab present but disabled (greyed, not clickable)
2. Search fires after 300ms debounce with 2-char minimum; spinner shows during load
3. Previous results stay visible while new results load (no flash-to-empty)
4. Tab switch immediately re-searches same query in the other service
5. Each result row: 60x90 poster (2:3) on left, title + year on right
6. Items with in_library=true and has_file=true → green "Available" badge
7. Items with in_library=true and has_file=false → blue "Monitored" badge
8. Items just requested this session → yellow "Requested" badge (disabled)
9. Items not in library → "Request" button
10. Tapping Request opens confirm dialog with title, profile, root folder
11. Confirming sends WS request command; success → "Requested" badge; failure → inline error + button reset
12. Poster load errors handled silently (img hidden, placeholder shown)
</success_criteria>

<output>
After completion, create `.planning/phases/03-movie-tv-request/03-02-SUMMARY.md` following the GSD summary template.
</output>
