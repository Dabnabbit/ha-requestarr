---
phase: 04-music-lidarr-request
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - custom_components/requestarr/const.py
  - custom_components/requestarr/api.py
  - custom_components/requestarr/websocket.py
  - custom_components/requestarr/frontend/requestarr-card.js
autonomous: false
requirements: [SRCH-03, REQT-03]

must_haves:
  truths:
    - "An artist can be added to Lidarr by sending a requestarr/request_artist WebSocket command with foreign_artist_id (string UUID) and title"
    - "The request uses quality profile, metadata profile, and root folder stored in config — not hardcoded"
    - "Duplicate artist requests return success=false with error_code=already_exists (not a JS promise rejection)"
    - "Music search results include metadata_profile name so the confirm dialog can display it"
    - "The Music tab in the card is active (not disabled) and searches via requestarr/search_music"
    - "Music result rows display circular 60px avatars with fanart.tv images where available"
    - "Artists without images show an initials placeholder with a deterministic color derived from the artist name"
    - "The confirm dialog for music shows: artist name, quality profile, metadata profile, root folder"
    - "On request success the button becomes a yellow 'Requested' badge (disabled); on failure inline error text appears"
  artifacts:
    - path: "custom_components/requestarr/const.py"
      provides: "WS_TYPE_REQUEST_ARTIST constant"
      contains: "WS_TYPE_REQUEST_ARTIST"
    - path: "custom_components/requestarr/api.py"
      provides: "ArrClient.async_request_artist method"
      exports: ["async_request_artist"]
    - path: "custom_components/requestarr/websocket.py"
      provides: "websocket_request_artist handler registered with HA; _normalize_music_result extended with metadata_profile"
      exports: ["websocket_request_artist"]
    - path: "custom_components/requestarr/frontend/requestarr-card.js"
      provides: "Active Music tab with circular avatar rows, initials placeholder, and artist request flow"
      min_lines: 250
      contains: "requestarr/request_artist"
  key_links:
    - from: "custom_components/requestarr/websocket.py"
      to: "custom_components/requestarr/api.py"
      via: "coordinator.get_client(SERVICE_LIDARR).async_request_artist(...)"
      pattern: "async_request_artist"
    - from: "custom_components/requestarr/websocket.py"
      to: "config entry data"
      via: "_get_config_data(hass)"
      pattern: "CONF_LIDARR_QUALITY_PROFILE_ID|CONF_LIDARR_METADATA_PROFILE_ID|CONF_LIDARR_ROOT_FOLDER"
    - from: "requestarr-card.js _doSearch()"
      to: "requestarr/search_music WS command"
      via: "this.hass.connection.sendMessagePromise({type: 'requestarr/search_music', query})"
      pattern: "search_music"
    - from: "requestarr-card.js _doRequest()"
      to: "requestarr/request_artist WS command"
      via: "this.hass.connection.sendMessagePromise({type: 'requestarr/request_artist', foreign_artist_id, title})"
      pattern: "request_artist"
---

<objective>
Complete Phase 4 in a single plan: add the `requestarr/request_artist` WebSocket backend command, extend the music result normalizer with `metadata_profile`, and activate the Music tab in the card with circular avatar rows, initials placeholder, and full request flow.

Purpose: This is the complete deliverable for Phase 4. The `search_music` backend command already exists from Phase 2. The card placeholder tab already exists from Phase 3. This plan wires everything together and adds the missing `request_artist` backend.

Output: Working Music tab with Lidarr artist search and one-click request, at full parity with Movies/TV tabs.
</objective>

<execution_context>
@/home/dab/.claude/get-shit-done/workflows/execute-plan.md
@/home/dab/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-music-lidarr-request/04-RESEARCH.md
@.planning/phases/04-music-lidarr-request/04-CONTEXT.md

<interfaces>
<!-- Existing code this plan extends. Read these before implementing. -->

From custom_components/requestarr/const.py (current):
```python
DOMAIN = "requestarr"
SERVICE_LIDARR = "lidarr"
CONF_LIDARR_QUALITY_PROFILE_ID = "lidarr_quality_profile_id"
CONF_LIDARR_ROOT_FOLDER = "lidarr_root_folder"
CONF_LIDARR_METADATA_PROFILE_ID = "lidarr_metadata_profile_id"
CONF_LIDARR_PROFILES = "lidarr_profiles"
CONF_LIDARR_FOLDERS = "lidarr_folders"
CONF_LIDARR_METADATA_PROFILES = "lidarr_metadata_profiles"
WS_TYPE_SEARCH_MUSIC = f"{DOMAIN}/search_music"
WS_TYPE_REQUEST_MOVIE = f"{DOMAIN}/request_movie"
WS_TYPE_REQUEST_TV = f"{DOMAIN}/request_series"
# MISSING: WS_TYPE_REQUEST_ARTIST — add in Task 1
```

From custom_components/requestarr/api.py (current):
```python
class ArrClient:
    async def _request(self, method: str, endpoint: str, **kwargs) -> Any: ...
    # _request raises CannotConnectError, InvalidAuthError, ServerError
    # For POST: await self._request("POST", "/artist", json=payload)
    # HTTP 400 from Lidarr add endpoint → ServerError (status 400 means duplicate)
    async def async_search(self, query: str) -> list[dict]: ...
    async def async_request_movie(...) -> dict: ...
    async def async_request_series(...) -> dict: ...
    # MISSING: async_request_artist — add in Task 2
```

From custom_components/requestarr/websocket.py (current):
```python
def _get_coordinator(hass): ...           # returns coordinator or None
def _get_config_data(hass) -> dict: ...   # returns entry.data as dict
def _resolve_profile_name(profiles, profile_id) -> str: ...

def _normalize_music_result(item, config_data) -> dict:
    # Currently returns: title, year (None), overview, poster_url, in_library,
    #                    arr_id, foreign_artist_id, quality_profile, root_folder
    # MISSING: metadata_profile — add in Task 3

async def websocket_search_music(hass, connection, msg): ...  # already registered

@callback
def async_setup_websocket(hass): ...
# Currently registers: get_data, search_movies, search_tv, search_music,
#                      request_movie, request_series
# MISSING: request_artist — add in Task 3
```

From custom_components/requestarr/frontend/requestarr-card.js (current):
```javascript
// Music tab currently disabled:
// <button class="tab disabled" disabled title="Coming in Phase 4">Music</button>

// _doSearch() currently handles only movies and tv:
// const type = this._activeTab === 'movies' ? 'requestarr/search_movies' : 'requestarr/search_tv';

// _doRequest() currently handles only movies and tv (no music branch)

// _getItemState(item) uses tmdb_id ?? tvdb_id as key — does not handle music

// _renderResultRow(item) renders 60x90 poster — does not handle circular avatars

// _renderDialog() shows quality profile and root folder — no metadata_profile line

// CARD_VERSION = "0.3.0" — bump to "0.4.0" in Task 4
```

Lidarr artist lookup result fields (from _normalize_music_result output, Phase 2):
```
{
    title: string,            # artist name (from "artistName")
    year: null,               # artists have no single year
    overview: string,
    poster_url: string|null,  # fanart.tv URL or null (~40-60% missing)
    in_library: bool,         # id > 0
    arr_id: int|null,
    foreign_artist_id: string, # MusicBrainz UUID — e.g. "5f9c3f52-3d52-4571-9f8b-..."
    quality_profile: string,  # resolved profile name
    root_folder: string,      # root folder path
    # metadata_profile: string  ← MISSING, add in Task 3
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add WS_TYPE_REQUEST_ARTIST constant to const.py</name>
  <files>
    custom_components/requestarr/const.py
  </files>
  <action>
Add one new constant to `const.py` in the "WebSocket command types — request" section, after the existing `WS_TYPE_REQUEST_TV` line:

```python
WS_TYPE_REQUEST_ARTIST = f"{DOMAIN}/request_artist"
```

This goes in the block with `WS_TYPE_REQUEST_MOVIE` and `WS_TYPE_REQUEST_TV` (around line 72-73 of the current file).
  </action>
  <verify>
    <automated>cd /home/dab/Projects/ha-requestarr && python -c "from custom_components.requestarr.const import WS_TYPE_REQUEST_ARTIST; print(WS_TYPE_REQUEST_ARTIST); assert WS_TYPE_REQUEST_ARTIST == 'requestarr/request_artist'"</automated>
  </verify>
  <done>
    - `WS_TYPE_REQUEST_ARTIST` constant is importable from `const.py`
    - Value is `"requestarr/request_artist"`
  </done>
</task>

<task type="auto">
  <name>Task 2: Add async_request_artist to ArrClient in api.py</name>
  <files>
    custom_components/requestarr/api.py
  </files>
  <action>
Add one new async method to `ArrClient` in `api.py` after `async_request_series`. Follow the exact same pattern as `async_request_movie` and `async_request_series`.

**Critical differences from movie/series:**
- `foreignArtistId` is a **string** (MusicBrainz UUID) — do NOT cast to int
- `metadataProfileId` is a **new required field** (no equivalent in Radarr/Sonarr)
- No `title` or `titleSlug` needed in the POST body (Lidarr fetches from MusicBrainz)
- Endpoint is `/artist` (not `/movie` or `/series`)
- `addOptions.searchForMissingAlbums: True` (equivalent of `searchForMovie`)

```python
async def async_request_artist(
    self,
    foreign_artist_id: str,
    quality_profile_id: int,
    metadata_profile_id: int,
    root_folder_path: str,
) -> dict[str, Any]:
    """Add an artist to Lidarr.

    Args:
        foreign_artist_id: MusicBrainz artist GUID (string UUID).
        quality_profile_id: Quality profile ID from config entry.
        metadata_profile_id: Metadata profile ID from config entry (Lidarr-specific).
        root_folder_path: Root folder path from config entry.

    Returns:
        Parsed JSON response from Lidarr.

    Raises:
        CannotConnectError: Cannot reach Lidarr.
        InvalidAuthError: API key rejected.
        ServerError: Non-auth HTTP error. HTTP 400 means artist already exists.
    """
    payload = {
        "foreignArtistId": foreign_artist_id,        # string UUID — DO NOT cast to int
        "qualityProfileId": int(quality_profile_id),
        "metadataProfileId": int(metadata_profile_id),
        "rootFolderPath": root_folder_path,
        "monitored": True,
        "addOptions": {
            "searchForMissingAlbums": True,
            "monitor": "all",
        },
    }
    return await self._request("POST", "/artist", json=payload)
```
  </action>
  <verify>
    <automated>cd /home/dab/Projects/ha-requestarr && python -c "
from custom_components.requestarr.api import ArrClient
import inspect
src = inspect.getsource(ArrClient.async_request_artist)
assert 'foreignArtistId' in src, 'Missing foreignArtistId'
assert 'metadataProfileId' in src, 'Missing metadataProfileId'
assert 'qualityProfileId' in src, 'Missing qualityProfileId'
assert 'int(quality_profile_id)' in src, 'qualityProfileId must be cast to int'
assert 'int(metadata_profile_id)' in src, 'metadataProfileId must be cast to int'
assert 'searchForMissingAlbums' in src, 'Missing searchForMissingAlbums'
assert '/artist' in src, 'Wrong endpoint'
# foreignArtistId should NOT be cast to int
assert 'int(foreign_artist_id)' not in src, 'foreignArtistId must NOT be cast to int (it is a UUID string)'
print('async_request_artist OK')
"</automated>
  </verify>
  <done>
    - `ArrClient.async_request_artist` exists in `api.py`
    - POSTs to `/artist` endpoint
    - Includes `foreignArtistId` (string, not cast to int), `qualityProfileId` (cast to int), `metadataProfileId` (cast to int), `rootFolderPath`, `monitored: True`, `addOptions.searchForMissingAlbums: True`
  </done>
</task>

<task type="auto">
  <name>Task 3: Extend normalizer + add request handler + register in websocket.py</name>
  <files>
    custom_components/requestarr/websocket.py
  </files>
  <action>
Three changes to `websocket.py`:

**Change A: Extend `_normalize_music_result` with `metadata_profile` field**

In the existing `_normalize_music_result` function, add `metadata_profile` to the returned dict after `quality_profile`. Use the same `_resolve_profile_name` helper with `CONF_LIDARR_METADATA_PROFILES` and `CONF_LIDARR_METADATA_PROFILE_ID`:

```python
"metadata_profile": _resolve_profile_name(
    config_data.get(CONF_LIDARR_METADATA_PROFILES, []),
    config_data.get(CONF_LIDARR_METADATA_PROFILE_ID),
),
```

Also add `WS_TYPE_REQUEST_ARTIST` to the imports from `.const` at the top of the file.

**Change B: Add `websocket_request_artist` handler**

Add after `websocket_request_series` and before the `async_setup_websocket` function:

```python
@websocket_api.websocket_command(
    {
        vol.Required("type"): WS_TYPE_REQUEST_ARTIST,
        vol.Required("foreign_artist_id"): str,   # MusicBrainz UUID string
        vol.Required("title"): str,               # artist name (for logging)
    }
)
@websocket_api.async_response
async def websocket_request_artist(
    hass: HomeAssistant,
    connection: websocket_api.ActiveConnection,
    msg: dict[str, Any],
) -> None:
    """Handle music artist request via Lidarr POST."""
    coordinator = _get_coordinator(hass)
    if coordinator is None:
        connection.send_result(
            msg["id"],
            {
                "success": False,
                "error_code": "not_configured",
                "message": "Requestarr not configured",
            },
        )
        return

    client = coordinator.get_client(SERVICE_LIDARR)
    if client is None:
        connection.send_result(
            msg["id"],
            {
                "success": False,
                "error_code": "service_not_configured",
                "message": "Lidarr is not configured",
            },
        )
        return

    config_data = _get_config_data(hass)
    quality_profile_id = config_data.get(CONF_LIDARR_QUALITY_PROFILE_ID)
    metadata_profile_id = config_data.get(CONF_LIDARR_METADATA_PROFILE_ID)
    root_folder = config_data.get(CONF_LIDARR_ROOT_FOLDER, "")

    try:
        await client.async_request_artist(
            foreign_artist_id=msg["foreign_artist_id"],
            quality_profile_id=quality_profile_id,
            metadata_profile_id=metadata_profile_id,
            root_folder_path=root_folder,
        )
        connection.send_result(msg["id"], {"success": True})
    except ServerError as err:
        err_str = str(err)
        # Lidarr 400 on the add endpoint means the artist is already in the library
        if "400" in err_str:
            connection.send_result(
                msg["id"],
                {
                    "success": False,
                    "error_code": "already_exists",
                    "message": "This artist is already in Lidarr",
                },
            )
        else:
            _LOGGER.warning("Artist request failed: %s", err)
            connection.send_result(
                msg["id"],
                {
                    "success": False,
                    "error_code": "service_unavailable",
                    "message": str(err),
                },
            )
    except (CannotConnectError, InvalidAuthError) as err:
        _LOGGER.warning("Artist request failed: %s", err)
        connection.send_result(
            msg["id"],
            {
                "success": False,
                "error_code": "service_unavailable",
                "message": str(err),
            },
        )
```

**Change C: Register `websocket_request_artist` in `async_setup_websocket`**

Add after the existing `websocket_api.async_register_command(hass, websocket_request_series)` line:

```python
websocket_api.async_register_command(hass, websocket_request_artist)
```
  </action>
  <verify>
    <automated>cd /home/dab/Projects/ha-requestarr && python -c "
import ast
with open('custom_components/requestarr/websocket.py') as f:
    src = f.read()
tree = ast.parse(src)
fns = [n.name for n in ast.walk(tree) if isinstance(n, ast.AsyncFunctionDef)]
assert 'websocket_request_artist' in fns, 'Missing websocket_request_artist function'
assert 'metadata_profile' in src, 'Missing metadata_profile in normalizer'
assert 'WS_TYPE_REQUEST_ARTIST' in src, 'Missing WS_TYPE_REQUEST_ARTIST import/use'
assert 'websocket_request_artist' in src, 'Not registered in async_setup_websocket?'
assert 'already_exists' in src, 'Missing already_exists error code'
assert 'CONF_LIDARR_METADATA_PROFILE_ID' in src, 'Missing metadata profile ID config read'
print('All websocket.py assertions passed')
"</automated>
  </verify>
  <done>
    - `_normalize_music_result` returns `metadata_profile` key (resolved from CONF_LIDARR_METADATA_PROFILES)
    - `WS_TYPE_REQUEST_ARTIST` is imported from `.const`
    - `websocket_request_artist` function exists with schema validating `foreign_artist_id` (str) and `title` (str)
    - Handler reads `quality_profile_id`, `metadata_profile_id`, `root_folder` from config
    - HTTP 400 maps to `error_code: "already_exists"` via `send_result` (not `send_error`)
    - Function is registered in `async_setup_websocket`
  </done>
</task>

<task type="auto">
  <name>Task 4: Activate Music tab and add circular avatar rows in requestarr-card.js</name>
  <files>
    custom_components/requestarr/frontend/requestarr-card.js
  </files>
  <action>
Five targeted changes to `requestarr-card.js`. This is a **targeted edit**, not a full rewrite — preserve all existing Movies/TV functionality.

**Change A: Bump CARD_VERSION to "0.4.0"**

Change the constant at the top:
```javascript
const CARD_VERSION = "0.4.0";
```

**Change B: Activate Music tab in `_renderTabs()`**

Replace the disabled Music button with an active tab button:

```javascript
_renderTabs() {
    return html`
      <div class="tabs">
        <button
          class="tab ${this._activeTab === "movies" ? "active" : ""}"
          @click="${() => this._switchTab("movies")}"
        >
          Movies
        </button>
        <button
          class="tab ${this._activeTab === "tv" ? "active" : ""}"
          @click="${() => this._switchTab("tv")}"
        >
          TV
        </button>
        <button
          class="tab ${this._activeTab === "music" ? "active" : ""}"
          @click="${() => this._switchTab("music")}"
        >
          Music
        </button>
      </div>
    `;
}
```

**Change C: Extend `_doSearch()` to handle music tab**

Replace the type determination in `_doSearch()`:

```javascript
const type =
    this._activeTab === "movies"
        ? "requestarr/search_movies"
        : this._activeTab === "tv"
        ? "requestarr/search_tv"
        : "requestarr/search_music";
```

**Change D: Extend `_getItemState()`, `_doRequest()`, `_renderResults()`, `_renderDialog()`, and add music-specific methods**

Replace `_getItemState` to handle music items:
```javascript
_getItemState(item) {
    const key = item.foreign_artist_id != null
        ? String(item.foreign_artist_id)
        : String(item.tmdb_id != null ? item.tmdb_id : item.tvdb_id);
    const reqState = this._requesting[key];
    if (reqState === "requested") return "requested";
    if (!item.in_library) return "not_in_library";
    if (item.has_file) return "available";
    return "monitored";
}
```

Replace `_doRequest` to handle music:
```javascript
async _doRequest(item) {
    const key = item.foreign_artist_id != null
        ? String(item.foreign_artist_id)
        : String(item.tmdb_id != null ? item.tmdb_id : item.tvdb_id);
    this._requesting = { ...this._requesting, [key]: "requesting" };
    this._dialogItem = null;

    let payload;
    if (this._activeTab === "movies") {
        payload = {
            type: "requestarr/request_movie",
            tmdb_id: item.tmdb_id,
            title: item.title,
            title_slug: item.title_slug,
        };
    } else if (this._activeTab === "tv") {
        payload = {
            type: "requestarr/request_series",
            tvdb_id: item.tvdb_id,
            title: item.title,
            title_slug: item.title_slug,
            seasons: item.seasons || [],
        };
    } else {
        // music
        payload = {
            type: "requestarr/request_artist",
            foreign_artist_id: item.foreign_artist_id,
            title: item.title,
        };
    }

    try {
        const resp = await this.hass.connection.sendMessagePromise(payload);
        if (resp.success) {
            this._requesting = { ...this._requesting, [key]: "requested" };
        } else {
            this._requesting = { ...this._requesting, [key]: "error" };
            this._requestError = {
                ...this._requestError,
                [key]: resp.message || "Request failed",
            };
        }
    } catch (_err) {
        this._requesting = { ...this._requesting, [key]: "error" };
        this._requestError = {
            ...this._requestError,
            [key]: "Connection error",
        };
    }
}
```

Add the `_hashColor` helper method (deterministic palette from artist name):
```javascript
_hashColor(name) {
    let h = 5381;
    for (let i = 0; i < name.length; i++) {
        h = ((h << 5) + h) ^ name.charCodeAt(i);
        h = h >>> 0;
    }
    const palette = [
        "#E57373", "#F06292", "#BA68C8", "#7986CB",
        "#4FC3F7", "#4DB6AC", "#81C784", "#FFD54F",
        "#FF8A65", "#A1887F",
    ];
    return palette[h % palette.length];
}
```

Add `_renderMusicResultRow` method for circular avatar rows:
```javascript
_renderMusicResultRow(item) {
    const key = String(item.foreign_artist_id);
    const state = this._getItemState(item);
    const reqErr = this._requestError[key];
    const initial = item.title ? item.title[0].toUpperCase() : "?";
    const color = this._hashColor(item.title || "");
    return html`
        <div class="result-row music-result-row">
            <div class="avatar-wrap">
                ${item.poster_url
                    ? html`<img
                            class="avatar"
                            src="${item.poster_url}"
                            alt=""
                            @error="${(e) => {
                                e.target.style.display = "none";
                            }}"
                        />`
                    : ""}
                <div
                    class="avatar-placeholder"
                    style="background-color: ${color}"
                >
                    ${initial}
                </div>
            </div>
            <div class="result-info">
                <span class="result-title">${item.title}</span>
                ${this._renderStatus(state, item)}
                ${reqErr
                    ? html`<span class="req-error">${reqErr}</span>`
                    : ""}
            </div>
        </div>
    `;
}
```

Extend `_renderResults()` to dispatch to music rows:
```javascript
_renderResults() {
    if (this._query.length < 2) return html``;
    if (!this._loading && this._results.length === 0) {
        return html`<div class="empty">No results for "${this._query}"</div>`;
    }
    return html`
        <div class="results">
            ${this._results.map((item) =>
                this._activeTab === "music"
                    ? this._renderMusicResultRow(item)
                    : this._renderResultRow(item)
            )}
        </div>
    `;
}
```

Extend `_renderDialog()` to show `metadata_profile` for music:
```javascript
_renderDialog() {
    if (!this._dialogItem) return html``;
    const item = this._dialogItem;
    const key = item.foreign_artist_id != null
        ? String(item.foreign_artist_id)
        : String(item.tmdb_id != null ? item.tmdb_id : item.tvdb_id);
    const isRequesting = this._requesting[key] === "requesting";
    return html`
        <div
            class="dialog-overlay"
            @click="${() => {
                this._dialogItem = null;
            }}"
        >
            <div
                class="dialog"
                @click="${(e) => e.stopPropagation()}"
            >
                <div class="dialog-title">${item.title}</div>
                <div class="dialog-meta">
                    <div>Profile: ${item.quality_profile || "\u2014"}</div>
                    ${this._activeTab === "music" && item.metadata_profile
                        ? html`<div>Metadata: ${item.metadata_profile}</div>`
                        : ""}
                    <div>Folder: ${item.root_folder || "\u2014"}</div>
                </div>
                <div class="dialog-actions">
                    <button
                        class="btn-cancel"
                        @click="${() => {
                            this._dialogItem = null;
                        }}"
                    >
                        Cancel
                    </button>
                    <button
                        class="btn-confirm"
                        ?disabled="${isRequesting}"
                        @click="${() => this._doRequest(item)}"
                    >
                        ${isRequesting ? "Requesting\u2026" : "Confirm"}
                    </button>
                </div>
            </div>
        </div>
    `;
}
```

**Change E: Add music CSS to `static get styles()`**

Add these CSS rules inside the existing `static get styles()` css template literal, after the existing poster/result styles and before the `/* Confirm dialog */` section:

```css
/* Music avatar (circular) */
.music-result-row {
    align-items: center;
}
.avatar-wrap {
    position: relative;
    flex-shrink: 0;
    width: 60px;
    height: 60px;
    border-radius: 50%;
    overflow: hidden;
    background: var(--secondary-background-color);
}
.avatar {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 50%;
}
.avatar-placeholder {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    font-size: 1.4rem;
    font-weight: 700;
    color: white;
}
```
  </action>
  <verify>
    <automated>cd /home/dab/Projects/ha-requestarr && node --input-type=module <<'EOF'
import { readFileSync } from 'fs';
const src = readFileSync('custom_components/requestarr/frontend/requestarr-card.js', 'utf8');

const checks = [
    ['version 0.4.0', src.includes('0.4.0')],
    ['Music tab active (not disabled)', src.includes("_switchTab(\"music\")") || src.includes("_switchTab('music')")],
    ['Music tab no longer disabled-only', !src.match(/disabled[^>]*>[\s\n]*Music/) || src.includes('_switchTab')],
    ['WS search_music', src.includes('requestarr/search_music')],
    ['WS request_artist', src.includes('requestarr/request_artist')],
    ['foreign_artist_id in payload', src.includes('foreign_artist_id')],
    ['_hashColor method', src.includes('_hashColor')],
    ['_renderMusicResultRow', src.includes('_renderMusicResultRow')],
    ['avatar-wrap CSS class', src.includes('avatar-wrap')],
    ['border-radius: 50%', src.includes('50%')],
    ['avatar-placeholder', src.includes('avatar-placeholder')],
    ['metadata_profile in dialog', src.includes('metadata_profile') || src.includes('metadata profile')],
    ['Metadata: label in dialog', src.includes('Metadata:') || src.includes('metadata_profile')],
    ['_hashColor palette 10 colors', (src.match(/#[0-9A-Fa-f]{6}/g) || []).length >= 10],
    ['Music tab in _doSearch ternary', src.includes('search_music')],
    ['sendMessagePromise preserved', src.includes('sendMessagePromise')],
    ['_searchSeq preserved', src.includes('_searchSeq')],
];

let failed = 0;
for (const [name, result] of checks) {
    if (!result) { console.error('FAIL:', name); failed++; }
    else console.log('OK:', name);
}
if (failed > 0) process.exit(1);
console.log('\nAll card checks passed');
EOF</automated>
  </verify>
  <done>
    - `CARD_VERSION` is `"0.4.0"`
    - Music tab is active (click handler wired, no `disabled` attribute)
    - `_doSearch()` handles `music` tab with `requestarr/search_music`
    - `_doRequest()` sends `requestarr/request_artist` for music tab with `foreign_artist_id` and `title`
    - `_hashColor(name)` method exists with 10-color palette
    - `_renderMusicResultRow(item)` renders circular 60px avatar, initials placeholder with deterministic color
    - Avatar placeholder always rendered; img has @error handler to hide on failure
    - `_renderResults()` dispatches to `_renderMusicResultRow` for music tab
    - `_renderDialog()` shows "Metadata:" line for music tab
    - CSS: `.avatar-wrap` is 60x60px with `border-radius: 50%`; `.music-result-row` uses `align-items: center`
    - Existing Movies/TV behavior unchanged
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Phase 4: `request_artist` WebSocket backend command, music result normalizer with `metadata_profile`, active Music tab with circular avatar rows, initials placeholder, and full Lidarr artist request flow. Backend parity with Phase 3 movie/TV commands; UI parity with Movies/TV tabs.
  </what-built>
  <how-to-verify>
1. Open the Requestarr card on a Lovelace dashboard. Verify all three tabs are now active: "Movies", "TV", and "Music" (no greyed-out disabled state).
2. Click the Music tab. Type 2+ characters in the search box. Verify results appear as circular avatar rows (not rectangular poster rows).
3. Find an artist that has a fanart.tv image (e.g., major artists like "Metallica", "Taylor Swift"). Verify the circular avatar shows the artist photo.
4. Find an artist without a fanart.tv image. Verify the circle shows the first letter of the artist name with a colored background. The same artist should always show the same color.
5. For a result not in the library, click "Request". Verify the confirm dialog opens showing: artist name, Profile (quality profile), Metadata (metadata profile), Folder (root folder).
6. Click Cancel — verify dialog closes, button resets.
7. Click Request again, then Confirm — verify button shows "Requesting..." during the request, then changes to a yellow "Requested" badge on success.
8. Try requesting an artist already in Lidarr — verify inline error shows "This artist is already in Lidarr" (not a JS error).
9. Switch back to Movies tab, verify search still works with rectangular poster rows (Phase 3 behavior unchanged).
10. Switch to TV tab, verify search still works (Phase 3 behavior unchanged).
  </how-to-verify>
  <resume-signal>Type "approved" if the Music tab works correctly, or describe any issues found.</resume-signal>
</task>

</tasks>

<verification>
Run the following to confirm full backend wiring:

```bash
cd /home/dab/Projects/ha-requestarr && python -c "
from custom_components.requestarr.const import WS_TYPE_REQUEST_ARTIST
from custom_components.requestarr.api import ArrClient
from custom_components.requestarr.websocket import (
    websocket_request_artist, async_setup_websocket
)
import inspect

# Verify constant
assert WS_TYPE_REQUEST_ARTIST == 'requestarr/request_artist'

# Verify ArrClient method
assert hasattr(ArrClient, 'async_request_artist')
src = inspect.getsource(ArrClient.async_request_artist)
assert 'foreignArtistId' in src
assert 'metadataProfileId' in src
assert 'searchForMissingAlbums' in src

# Verify normalizer has metadata_profile
ws_src = inspect.getsource(
    __import__('custom_components.requestarr.websocket', fromlist=['websocket'])
)
assert 'metadata_profile' in ws_src
assert 'websocket_request_artist' in ws_src
assert 'already_exists' in ws_src

print('Phase 4 Plan 01: ALL CHECKS PASSED')
"
```

Frontend static checks:
```bash
cd /home/dab/Projects/ha-requestarr && node --input-type=module <<'EOF'
import { readFileSync } from 'fs';
const src = readFileSync('custom_components/requestarr/frontend/requestarr-card.js', 'utf8');
const required = [
    'requestarr/search_music', 'requestarr/request_artist',
    'foreign_artist_id', '_hashColor', '_renderMusicResultRow',
    'avatar-wrap', '50%', 'avatar-placeholder', '0.4.0',
];
const missing = required.filter(s => !src.includes(s));
if (missing.length) { console.error('Missing:', missing); process.exit(1); }
console.log('All frontend static checks passed');
EOF
```
</verification>

<success_criteria>
1. `requestarr/request_artist` WebSocket command registered — validates `foreign_artist_id` (str) and `title` (str)
2. Command POSTs to Lidarr `/api/v1/artist` with `foreignArtistId` (str), `qualityProfileId` (int), `metadataProfileId` (int), `rootFolderPath`
3. HTTP 400 from Lidarr maps to `error_code: "already_exists"` via `send_result` (never `send_error`)
4. Music search results include `metadata_profile` name field
5. Music tab is active in the card (not disabled)
6. Music result rows display 60px circular avatars (CSS `border-radius: 50%`)
7. Artists with `poster_url` show the fanart.tv image in the circle
8. Artists without `poster_url` (or failed img load) show first-letter initial on deterministic background color
9. Confirm dialog for music shows: title, quality profile, metadata profile, root folder
10. Request flow identical to Phase 3: Confirm → "Requested" badge (yellow) on success; inline error on failure
11. Movies/TV tab behavior unchanged from Phase 3
</success_criteria>

<output>
After completion, create `.planning/phases/04-music-lidarr-request/04-01-SUMMARY.md` following the GSD summary template.
</output>
