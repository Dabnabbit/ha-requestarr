---
phase: 05-library-state-card-polish-validation
plan: "02"
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/conftest.py
  - tests/test_config_flow.py
  - tests/test_coordinator.py
  - tests/test_websocket.py
  - tests/test_sensor.py
  - README.md
autonomous: true
requirements:
  - REQT-05
  - CARD-05

must_haves:
  truths:
    - "pytest tests/ passes with no failures (all tests green)"
    - "Tests cover config flow 3-step wizard with real Requestarr config keys"
    - "Tests cover coordinator partial failure (one service down, others succeed)"
    - "Tests cover WebSocket search including in_library=true when arr id > 0"
    - "Tests cover request_movie, request_series, and request_artist WS handlers"
    - "README documents the full feature set including all three media types"
  artifacts:
    - path: "tests/conftest.py"
      provides: "Requestarr-specific fixtures: radarr_entry, sonarr_entry, lidarr_entry, all_services_entry"
      contains: "CONF_RADARR_URL"
    - path: "tests/test_config_flow.py"
      provides: "Config flow tests using Requestarr 3-step wizard"
      contains: "RequestarrConfigFlow"
    - path: "tests/test_coordinator.py"
      provides: "Coordinator tests including partial failure behavior"
      contains: "RequestarrCoordinator"
    - path: "tests/test_websocket.py"
      provides: "WebSocket search and request handler tests"
      contains: "in_library"
    - path: "tests/test_sensor.py"
      provides: "Sensor tests for RequestarrSensor"
      contains: "RequestarrSensor"
    - path: "README.md"
      provides: "Complete user documentation"
      contains: "Movies, TV, and music"
  key_links:
    - from: "tests/conftest.py"
      to: "custom_components/requestarr/const.py"
      via: "imports CONF_RADARR_URL, CONF_RADARR_API_KEY etc."
      pattern: "CONF_RADARR_URL"
    - from: "tests/test_coordinator.py"
      to: "custom_components/requestarr/coordinator.py"
      via: "patches ArrClient.async_get_library_count"
      pattern: "RequestarrCoordinator"
    - from: "tests/test_websocket.py"
      to: "custom_components/requestarr/websocket.py"
      via: "hass_ws_client sends WS messages, patches ArrClient.async_search"
      pattern: "in_library"
---

<objective>
Upgrade the test package to match the integration's HA version, rewrite all four test files for Requestarr-specific logic, and update the README with complete documentation.

Purpose: The existing test files test scaffold template patterns (TemplateCoordinator, ApiClient.async_get_data), not the actual Requestarr codebase. All four must be completely rewritten. The package upgrade (pytest-ha-cc 0.13.205 → 0.13.316) is required because the integration imports async_register_static_paths which was added in HA 2025.7 — the old package bundles HA 2025.1.4 and fails immediately.

Output: Working pytest test suite covering all four required areas (config flow, coordinator, WebSocket, sensor), and an updated README documenting all features.
</objective>

<execution_context>
@/home/dab/.claude/get-shit-done/workflows/execute-plan.md
@/home/dab/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/05-library-state-card-polish-validation/05-CONTEXT.md
@.planning/phases/05-library-state-card-polish-validation/05-RESEARCH.md

<interfaces>
<!-- Key source code contracts. Executor uses these directly — no codebase exploration needed. -->

From custom_components/requestarr/const.py — config keys:
```python
DOMAIN = "requestarr"
SERVICE_RADARR = "radarr"
SERVICE_SONARR = "sonarr"
SERVICE_LIDARR = "lidarr"
CONF_RADARR_URL = "radarr_url"
CONF_RADARR_API_KEY = "radarr_api_key"
CONF_RADARR_VERIFY_SSL = "radarr_verify_ssl"
CONF_RADARR_QUALITY_PROFILE_ID = "radarr_quality_profile_id"
CONF_RADARR_ROOT_FOLDER = "radarr_root_folder"
CONF_RADARR_PROFILES = "radarr_profiles"
CONF_RADARR_FOLDERS = "radarr_folders"
CONF_SONARR_URL = "sonarr_url"; CONF_SONARR_API_KEY = "sonarr_api_key"
CONF_SONARR_VERIFY_SSL = "sonarr_verify_ssl"
CONF_SONARR_QUALITY_PROFILE_ID = "sonarr_quality_profile_id"
CONF_SONARR_ROOT_FOLDER = "sonarr_root_folder"
CONF_SONARR_PROFILES = "sonarr_profiles"; CONF_SONARR_FOLDERS = "sonarr_folders"
CONF_LIDARR_URL = "lidarr_url"; CONF_LIDARR_API_KEY = "lidarr_api_key"
CONF_LIDARR_VERIFY_SSL = "lidarr_verify_ssl"
CONF_LIDARR_QUALITY_PROFILE_ID = "lidarr_quality_profile_id"
CONF_LIDARR_ROOT_FOLDER = "lidarr_root_folder"
CONF_LIDARR_METADATA_PROFILE_ID = "lidarr_metadata_profile_id"
CONF_LIDARR_PROFILES = "lidarr_profiles"; CONF_LIDARR_FOLDERS = "lidarr_folders"
CONF_LIDARR_METADATA_PROFILES = "lidarr_metadata_profiles"
WS_TYPE_SEARCH_MOVIES = "requestarr/search_movies"
WS_TYPE_SEARCH_TV = "requestarr/search_tv"
WS_TYPE_SEARCH_MUSIC = "requestarr/search_music"
WS_TYPE_REQUEST_MOVIE = "requestarr/request_movie"
WS_TYPE_REQUEST_TV = "requestarr/request_series"
WS_TYPE_REQUEST_ARTIST = "requestarr/request_artist"
```

From custom_components/requestarr/coordinator.py:
```python
class RequestarrCoordinator(DataUpdateCoordinator[dict[str, Any]]):
    def __init__(self, hass, entry): ...   # builds ArrClient instances from entry.data
    def get_client(self, service_type): ...  # returns ArrClient | None
    async def _async_update_data(self) -> dict[str, Any]:
        # Returns {f"{service}_count": int|None, f"{service}_last_sync": str, "errors": dict}
        # Raises UpdateFailed if ALL configured services fail
```

From custom_components/requestarr/api.py (inferred from coordinator imports):
```python
class ArrClient:
    async def async_get_library_count(self) -> int: ...
    async def async_search(self, query: str) -> list[dict]: ...
    async def async_validate_connection(self) -> None: ...
    async def async_request_movie(self, tmdb_id, title, title_slug,
                                   quality_profile_id, root_folder_path): ...
    async def async_request_series(self, tvdb_id, title, title_slug,
                                    quality_profile_id, root_folder_path, seasons): ...
    async def async_request_artist(self, foreign_artist_id, quality_profile_id,
                                    metadata_profile_id, root_folder_path): ...

class CannotConnectError(Exception): ...
class InvalidAuthError(Exception): ...
class ServerError(Exception): ...  # contains status code in str()
```

From custom_components/requestarr/config_flow.py (key flows):
```python
# Steps: "radarr" -> "sonarr" -> "lidarr"
# Skip field keys: SKIP_RADARR = "skip_radarr", SKIP_SONARR = "skip_sonarr", SKIP_LIDARR = "skip_lidarr"
# Validation: calls ArrClient.async_validate_connection()
# On success: calls ArrClient.async_get_quality_profiles(), async_get_root_folders()
# For Lidarr: also calls async_get_metadata_profiles()
# unique_id = DOMAIN (singleton integration)
```

From current tests/conftest.py (scaffold version — this is what we're REPLACING):
```python
# Uses CONF_HOST, CONF_PORT, CONF_API_KEY — WRONG for Requestarr
# mock_config_entry fixture uses wrong keys
# Must be completely rewritten
```

From pyproject.toml (relevant pytest config):
```toml
[tool.pytest.ini_options]
asyncio_mode = "auto"
testpaths = ["tests"]
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Upgrade test package and rewrite conftest.py with Requestarr fixtures</name>
  <files>tests/conftest.py</files>
  <action>
**Step 1: Upgrade pytest-homeassistant-custom-component.**

Run this command first and verify it succeeds:
```bash
pip install --user --break-system-packages "pytest-homeassistant-custom-component==0.13.316"
```

If that fails with a permissions error, try:
```bash
pip install --break-system-packages "pytest-homeassistant-custom-component==0.13.316"
```

**Step 2: Verify pytest is importable with the new package:**
```bash
cd /home/dab/Projects/ha-requestarr && /home/dab/.local/bin/pytest --collect-only tests/ 2>&1 | head -20
```

If you see `ImportError: cannot import name 'async_register_static_paths'`, the upgrade did not take effect. Check with `pip show pytest-homeassistant-custom-component`.

**Step 3: Rewrite tests/conftest.py.**

Replace the entire file with the following. The four fixtures provide minimal but complete config entry data that the coordinator uses to build ArrClient instances:

```python
"""Common fixtures for the Requestarr tests."""

from collections.abc import Generator
from unittest.mock import AsyncMock, patch

import pytest

from pytest_homeassistant_custom_component.common import MockConfigEntry

from custom_components.requestarr.const import (
    DOMAIN,
    CONF_RADARR_URL,
    CONF_RADARR_API_KEY,
    CONF_RADARR_VERIFY_SSL,
    CONF_RADARR_QUALITY_PROFILE_ID,
    CONF_RADARR_ROOT_FOLDER,
    CONF_RADARR_PROFILES,
    CONF_RADARR_FOLDERS,
    CONF_SONARR_URL,
    CONF_SONARR_API_KEY,
    CONF_SONARR_VERIFY_SSL,
    CONF_SONARR_QUALITY_PROFILE_ID,
    CONF_SONARR_ROOT_FOLDER,
    CONF_SONARR_PROFILES,
    CONF_SONARR_FOLDERS,
    CONF_LIDARR_URL,
    CONF_LIDARR_API_KEY,
    CONF_LIDARR_VERIFY_SSL,
    CONF_LIDARR_QUALITY_PROFILE_ID,
    CONF_LIDARR_ROOT_FOLDER,
    CONF_LIDARR_METADATA_PROFILE_ID,
    CONF_LIDARR_PROFILES,
    CONF_LIDARR_FOLDERS,
    CONF_LIDARR_METADATA_PROFILES,
)


@pytest.fixture(autouse=True)
def auto_enable_custom_integrations(enable_custom_integrations):
    """Enable custom integrations for all tests in this package."""
    yield


@pytest.fixture
def mock_setup_entry() -> Generator[AsyncMock]:
    """Override async_setup_entry to prevent full integration setup during config flow tests."""
    with patch(
        "custom_components.requestarr.async_setup_entry",
        return_value=True,
    ) as mock_setup_entry:
        yield mock_setup_entry


@pytest.fixture
def radarr_entry() -> MockConfigEntry:
    """Config entry with only Radarr configured."""
    return MockConfigEntry(
        domain=DOMAIN,
        unique_id=DOMAIN,
        data={
            CONF_RADARR_URL: "http://192.168.1.50:7878",
            CONF_RADARR_API_KEY: "radarr-test-key",
            CONF_RADARR_VERIFY_SSL: True,
            CONF_RADARR_QUALITY_PROFILE_ID: 1,
            CONF_RADARR_ROOT_FOLDER: "/movies",
            CONF_RADARR_PROFILES: [{"id": 1, "name": "HD-1080p"}],
            CONF_RADARR_FOLDERS: [{"id": 1, "path": "/movies"}],
        },
    )


@pytest.fixture
def sonarr_entry() -> MockConfigEntry:
    """Config entry with only Sonarr configured."""
    return MockConfigEntry(
        domain=DOMAIN,
        unique_id=DOMAIN,
        data={
            CONF_SONARR_URL: "http://192.168.1.50:8989",
            CONF_SONARR_API_KEY: "sonarr-test-key",
            CONF_SONARR_VERIFY_SSL: True,
            CONF_SONARR_QUALITY_PROFILE_ID: 2,
            CONF_SONARR_ROOT_FOLDER: "/tv",
            CONF_SONARR_PROFILES: [{"id": 2, "name": "HD-1080p"}],
            CONF_SONARR_FOLDERS: [{"id": 1, "path": "/tv"}],
        },
    )


@pytest.fixture
def lidarr_entry() -> MockConfigEntry:
    """Config entry with only Lidarr configured."""
    return MockConfigEntry(
        domain=DOMAIN,
        unique_id=DOMAIN,
        data={
            CONF_LIDARR_URL: "http://192.168.1.50:8686",
            CONF_LIDARR_API_KEY: "lidarr-test-key",
            CONF_LIDARR_VERIFY_SSL: True,
            CONF_LIDARR_QUALITY_PROFILE_ID: 1,
            CONF_LIDARR_ROOT_FOLDER: "/music",
            CONF_LIDARR_METADATA_PROFILE_ID: 1,
            CONF_LIDARR_PROFILES: [{"id": 1, "name": "Lossless"}],
            CONF_LIDARR_FOLDERS: [{"id": 1, "path": "/music"}],
            CONF_LIDARR_METADATA_PROFILES: [{"id": 1, "name": "Standard"}],
        },
    )


@pytest.fixture
def all_services_entry() -> MockConfigEntry:
    """Config entry with all three arr services configured."""
    return MockConfigEntry(
        domain=DOMAIN,
        unique_id=DOMAIN,
        data={
            CONF_RADARR_URL: "http://192.168.1.50:7878",
            CONF_RADARR_API_KEY: "radarr-test-key",
            CONF_RADARR_VERIFY_SSL: True,
            CONF_RADARR_QUALITY_PROFILE_ID: 1,
            CONF_RADARR_ROOT_FOLDER: "/movies",
            CONF_RADARR_PROFILES: [{"id": 1, "name": "HD-1080p"}],
            CONF_RADARR_FOLDERS: [{"id": 1, "path": "/movies"}],
            CONF_SONARR_URL: "http://192.168.1.50:8989",
            CONF_SONARR_API_KEY: "sonarr-test-key",
            CONF_SONARR_VERIFY_SSL: True,
            CONF_SONARR_QUALITY_PROFILE_ID: 2,
            CONF_SONARR_ROOT_FOLDER: "/tv",
            CONF_SONARR_PROFILES: [{"id": 2, "name": "HD-1080p"}],
            CONF_SONARR_FOLDERS: [{"id": 1, "path": "/tv"}],
            CONF_LIDARR_URL: "http://192.168.1.50:8686",
            CONF_LIDARR_API_KEY: "lidarr-test-key",
            CONF_LIDARR_VERIFY_SSL: True,
            CONF_LIDARR_QUALITY_PROFILE_ID: 1,
            CONF_LIDARR_ROOT_FOLDER: "/music",
            CONF_LIDARR_METADATA_PROFILE_ID: 1,
            CONF_LIDARR_PROFILES: [{"id": 1, "name": "Lossless"}],
            CONF_LIDARR_FOLDERS: [{"id": 1, "path": "/music"}],
            CONF_LIDARR_METADATA_PROFILES: [{"id": 1, "name": "Standard"}],
        },
    )
```
  </action>
  <verify>
cd /home/dab/Projects/ha-requestarr && /home/dab/.local/bin/pytest tests/conftest.py --collect-only 2>&1 | tail -5
  </verify>
  <done>
- pytest-homeassistant-custom-component 0.13.316 installed (no ImportError on collect)
- tests/conftest.py imports from custom_components.requestarr.const (not homeassistant.const)
- Four fixtures: radarr_entry, sonarr_entry, lidarr_entry, all_services_entry
- All fixtures use Requestarr-specific config keys (CONF_RADARR_URL etc.)
- mock_setup_entry and auto_enable_custom_integrations fixtures preserved
  </done>
</task>

<task type="auto">
  <name>Task 2: Rewrite test_config_flow.py, test_coordinator.py, test_websocket.py, test_sensor.py and update README</name>
  <files>
    tests/test_config_flow.py
    tests/test_coordinator.py
    tests/test_websocket.py
    tests/test_sensor.py
    README.md
  </files>
  <action>
Rewrite each test file completely. Use inline mock data (not JSON fixture files). Use `AsyncMock` and `patch` from unittest.mock. Patch target paths use the actual module path: `custom_components.requestarr.api.ArrClient`.

**File 1: tests/test_config_flow.py**

Test the real 3-step Requestarr config flow. The config flow has steps "radarr" → "sonarr" → "lidarr". Each step has a skip checkbox. At least one service must be configured.

```python
"""Tests for Requestarr config flow."""

from unittest.mock import AsyncMock, patch

import pytest

from homeassistant.config_entries import SOURCE_USER
from homeassistant.core import HomeAssistant
from homeassistant.data_entry_flow import FlowResultType

from custom_components.requestarr.const import (
    DOMAIN,
    CONF_RADARR_URL,
    CONF_RADARR_API_KEY,
    CONF_RADARR_VERIFY_SSL,
)
from custom_components.requestarr.config_flow import (
    SKIP_RADARR,
    SKIP_SONARR,
    SKIP_LIDARR,
)


@pytest.fixture
def mock_validate():
    """Patch ArrClient.async_validate_connection to succeed silently."""
    with patch(
        "custom_components.requestarr.config_flow.ArrClient.async_validate_connection",
        new_callable=AsyncMock,
        return_value=None,
    ) as m:
        yield m


@pytest.fixture
def mock_profiles():
    """Patch profile/folder/metadata fetches to return minimal data."""
    with (
        patch(
            "custom_components.requestarr.config_flow.ArrClient.async_get_quality_profiles",
            new_callable=AsyncMock,
            return_value=[{"id": 1, "name": "HD-1080p"}],
        ),
        patch(
            "custom_components.requestarr.config_flow.ArrClient.async_get_root_folders",
            new_callable=AsyncMock,
            return_value=[{"id": 1, "path": "/data"}],
        ),
        patch(
            "custom_components.requestarr.config_flow.ArrClient.async_get_metadata_profiles",
            new_callable=AsyncMock,
            return_value=[{"id": 1, "name": "Standard"}],
        ),
    ):
        yield


async def test_config_flow_radarr_only(
    hass: HomeAssistant, mock_setup_entry, mock_validate, mock_profiles
) -> None:
    """Configure Radarr only; skip Sonarr and Lidarr."""
    # Step 1: Radarr
    result = await hass.config_entries.flow.async_init(
        DOMAIN, context={"source": SOURCE_USER}
    )
    assert result["type"] == FlowResultType.FORM
    assert result["step_id"] == "radarr"

    result = await hass.config_entries.flow.async_configure(
        result["flow_id"],
        {
            CONF_RADARR_URL: "http://192.168.1.50:7878",
            CONF_RADARR_API_KEY: "radarr-key",
            CONF_RADARR_VERIFY_SSL: True,
            SKIP_RADARR: False,
        },
    )
    # Step 2: Sonarr — skip it
    assert result["type"] == FlowResultType.FORM
    assert result["step_id"] == "sonarr"
    result = await hass.config_entries.flow.async_configure(
        result["flow_id"],
        {SKIP_SONARR: True},
    )
    # Step 3: Lidarr — skip it
    assert result["type"] == FlowResultType.FORM
    assert result["step_id"] == "lidarr"
    result = await hass.config_entries.flow.async_configure(
        result["flow_id"],
        {SKIP_LIDARR: True},
    )
    await hass.async_block_till_done()

    assert result["type"] == FlowResultType.CREATE_ENTRY
    assert result["data"][CONF_RADARR_URL] == "http://192.168.1.50:7878"
    assert len(mock_setup_entry.mock_calls) == 1


async def test_config_flow_cannot_connect(
    hass: HomeAssistant, mock_setup_entry
) -> None:
    """Connection failure in Radarr step shows error and stays on radarr form."""
    from custom_components.requestarr.api import CannotConnectError

    result = await hass.config_entries.flow.async_init(
        DOMAIN, context={"source": SOURCE_USER}
    )

    with patch(
        "custom_components.requestarr.config_flow.ArrClient.async_validate_connection",
        new_callable=AsyncMock,
        side_effect=CannotConnectError("refused"),
    ):
        result = await hass.config_entries.flow.async_configure(
            result["flow_id"],
            {
                CONF_RADARR_URL: "http://bad-host:7878",
                CONF_RADARR_API_KEY: "bad-key",
                CONF_RADARR_VERIFY_SSL: True,
                SKIP_RADARR: False,
            },
        )

    assert result["type"] == FlowResultType.FORM
    assert result["step_id"] == "radarr"
    assert "base" in result["errors"]


async def test_config_flow_abort_already_configured(
    hass: HomeAssistant, radarr_entry
) -> None:
    """Config flow aborts when integration already configured (unique_id = DOMAIN)."""
    radarr_entry.add_to_hass(hass)

    result = await hass.config_entries.flow.async_init(
        DOMAIN, context={"source": SOURCE_USER}
    )
    assert result["type"] == FlowResultType.ABORT
    assert result["reason"] == "already_configured"
```

**File 2: tests/test_coordinator.py**

Test RequestarrCoordinator — the actual class, not TemplateCoordinator.

```python
"""Tests for Requestarr coordinator."""

from unittest.mock import AsyncMock, patch

import pytest

from homeassistant.core import HomeAssistant
from homeassistant.helpers.update_coordinator import UpdateFailed

from custom_components.requestarr.api import ArrClient, CannotConnectError
from custom_components.requestarr.coordinator import RequestarrCoordinator


async def test_coordinator_single_service_update(
    hass: HomeAssistant, radarr_entry
) -> None:
    """Coordinator polls Radarr library count successfully."""
    radarr_entry.add_to_hass(hass)
    with patch.object(
        ArrClient, "async_get_library_count", new_callable=AsyncMock, return_value=42
    ):
        coordinator = RequestarrCoordinator(hass, radarr_entry)
        await coordinator.async_refresh()

    assert coordinator.data["radarr_count"] == 42
    assert "sonarr_count" not in coordinator.data


async def test_coordinator_partial_failure(
    hass: HomeAssistant, all_services_entry
) -> None:
    """Radarr fails but Sonarr and Lidarr succeed — coordinator data still valid."""
    all_services_entry.add_to_hass(hass)
    call_count = 0

    async def mock_count(self):
        nonlocal call_count
        call_count += 1
        if call_count == 1:
            raise CannotConnectError("Radarr down")
        return 10

    with patch.object(ArrClient, "async_get_library_count", new=mock_count):
        coordinator = RequestarrCoordinator(hass, all_services_entry)
        await coordinator.async_refresh()

    assert coordinator.data["radarr_count"] is None
    assert coordinator.data.get("sonarr_count") == 10
    # UpdateFailed NOT raised — partial failure is tolerated


async def test_coordinator_all_services_fail(
    hass: HomeAssistant, radarr_entry
) -> None:
    """When all configured services fail, coordinator raises UpdateFailed."""
    radarr_entry.add_to_hass(hass)
    with patch.object(
        ArrClient,
        "async_get_library_count",
        new_callable=AsyncMock,
        side_effect=CannotConnectError("down"),
    ):
        coordinator = RequestarrCoordinator(hass, radarr_entry)
        with pytest.raises(UpdateFailed):
            await coordinator.async_refresh()


async def test_coordinator_get_client(hass: HomeAssistant, radarr_entry) -> None:
    """get_client returns ArrClient for configured services, None for unconfigured."""
    radarr_entry.add_to_hass(hass)
    coordinator = RequestarrCoordinator(hass, radarr_entry)

    assert coordinator.get_client("radarr") is not None
    assert coordinator.get_client("sonarr") is None
    assert coordinator.get_client("lidarr") is None
```

**File 3: tests/test_websocket.py**

Test the WebSocket search and request handlers. Focus on in_library detection and error codes.

```python
"""Tests for Requestarr WebSocket handlers."""

from unittest.mock import AsyncMock, patch

import pytest

from homeassistant.core import HomeAssistant

from custom_components.requestarr.api import ArrClient, CannotConnectError, ServerError


async def _setup_and_connect(hass, entry, mock_count=5):
    """Helper: add entry, patch library count, setup integration, return ws client."""
    from pytest_homeassistant_custom_component.common import MockConfigEntry

    entry.add_to_hass(hass)
    with patch.object(
        ArrClient, "async_get_library_count", new_callable=AsyncMock, return_value=mock_count
    ):
        assert await hass.config_entries.async_setup(entry.entry_id)
        await hass.async_block_till_done()


async def test_search_movies_in_library(
    hass: HomeAssistant, hass_ws_client, radarr_entry
) -> None:
    """Search result with id > 0 has in_library=True and TMDB URL rewritten to w300."""
    raw = [
        {
            "id": 42,
            "title": "Inception",
            "year": 2010,
            "tmdbId": 27205,
            "titleSlug": "inception",
            "hasFile": True,
            "remotePoster": "https://image.tmdb.org/t/p/original/test.jpg",
        }
    ]
    with patch.object(
        ArrClient, "async_get_library_count", new_callable=AsyncMock, return_value=1
    ):
        with patch.object(
            ArrClient, "async_search", new_callable=AsyncMock, return_value=raw
        ):
            radarr_entry.add_to_hass(hass)
            assert await hass.config_entries.async_setup(radarr_entry.entry_id)
            await hass.async_block_till_done()
            client = await hass_ws_client(hass)
            await client.send_json(
                {"id": 1, "type": "requestarr/search_movies", "query": "inception"}
            )
            result = await client.receive_json()

    assert result["success"] is True
    item = result["result"]["results"][0]
    assert item["in_library"] is True
    assert item["arr_id"] == 42
    assert item["poster_url"] == "https://image.tmdb.org/t/p/w300/test.jpg"


async def test_search_movies_not_in_library(
    hass: HomeAssistant, hass_ws_client, radarr_entry
) -> None:
    """Search result with id == 0 has in_library=False."""
    raw = [
        {
            "id": 0,
            "title": "Dune Part Two",
            "year": 2024,
            "tmdbId": 693134,
            "titleSlug": "dune-part-two",
            "hasFile": False,
            "remotePoster": "https://image.tmdb.org/t/p/original/poster.jpg",
        }
    ]
    with patch.object(
        ArrClient, "async_get_library_count", new_callable=AsyncMock, return_value=0
    ):
        with patch.object(
            ArrClient, "async_search", new_callable=AsyncMock, return_value=raw
        ):
            radarr_entry.add_to_hass(hass)
            assert await hass.config_entries.async_setup(radarr_entry.entry_id)
            await hass.async_block_till_done()
            client = await hass_ws_client(hass)
            await client.send_json(
                {"id": 1, "type": "requestarr/search_movies", "query": "dune"}
            )
            result = await client.receive_json()

    assert result["success"] is True
    item = result["result"]["results"][0]
    assert item["in_library"] is False
    assert item["arr_id"] is None


async def test_search_music_in_library(
    hass: HomeAssistant, hass_ws_client, lidarr_entry
) -> None:
    """Lidarr artist search result with id > 0 has in_library=True."""
    raw = [
        {
            "id": 7,
            "artistName": "Radiohead",
            "overview": "British rock band",
            "foreignArtistId": "a74b1b7f-71a5-4011-9441-d0b5e4122711",
        }
    ]
    with patch.object(
        ArrClient, "async_get_library_count", new_callable=AsyncMock, return_value=1
    ):
        with patch.object(
            ArrClient, "async_search", new_callable=AsyncMock, return_value=raw
        ):
            lidarr_entry.add_to_hass(hass)
            assert await hass.config_entries.async_setup(lidarr_entry.entry_id)
            await hass.async_block_till_done()
            client = await hass_ws_client(hass)
            await client.send_json(
                {"id": 1, "type": "requestarr/search_music", "query": "radiohead"}
            )
            result = await client.receive_json()

    assert result["success"] is True
    item = result["result"]["results"][0]
    assert item["in_library"] is True
    assert item["title"] == "Radiohead"


async def test_search_empty_query_rejected(
    hass: HomeAssistant, hass_ws_client, radarr_entry
) -> None:
    """Empty query returns error with invalid_query code."""
    with patch.object(
        ArrClient, "async_get_library_count", new_callable=AsyncMock, return_value=5
    ):
        radarr_entry.add_to_hass(hass)
        assert await hass.config_entries.async_setup(radarr_entry.entry_id)
        await hass.async_block_till_done()
        client = await hass_ws_client(hass)
        await client.send_json(
            {"id": 1, "type": "requestarr/search_movies", "query": "   "}
        )
        result = await client.receive_json()

    assert result["success"] is True  # send_result not send_error
    assert result["result"]["error"] == "invalid_query"
    assert result["result"]["results"] == []


async def test_request_movie_success(
    hass: HomeAssistant, hass_ws_client, radarr_entry
) -> None:
    """Successful movie request returns success=True."""
    with patch.object(
        ArrClient, "async_get_library_count", new_callable=AsyncMock, return_value=5
    ):
        with patch.object(
            ArrClient, "async_request_movie", new_callable=AsyncMock, return_value=None
        ):
            radarr_entry.add_to_hass(hass)
            assert await hass.config_entries.async_setup(radarr_entry.entry_id)
            await hass.async_block_till_done()
            client = await hass_ws_client(hass)
            await client.send_json(
                {
                    "id": 1,
                    "type": "requestarr/request_movie",
                    "tmdb_id": 27205,
                    "title": "Inception",
                    "title_slug": "inception",
                }
            )
            result = await client.receive_json()

    assert result["success"] is True
    assert result["result"]["success"] is True


async def test_request_movie_already_exists(
    hass: HomeAssistant, hass_ws_client, radarr_entry
) -> None:
    """Movie already in Radarr (HTTP 400) returns already_exists error code."""
    with patch.object(
        ArrClient, "async_get_library_count", new_callable=AsyncMock, return_value=5
    ):
        with patch.object(
            ArrClient,
            "async_request_movie",
            new_callable=AsyncMock,
            side_effect=ServerError("HTTP 400: Movie already exists"),
        ):
            radarr_entry.add_to_hass(hass)
            assert await hass.config_entries.async_setup(radarr_entry.entry_id)
            await hass.async_block_till_done()
            client = await hass_ws_client(hass)
            await client.send_json(
                {
                    "id": 1,
                    "type": "requestarr/request_movie",
                    "tmdb_id": 27205,
                    "title": "Inception",
                    "title_slug": "inception",
                }
            )
            result = await client.receive_json()

    assert result["success"] is True  # send_result, not send_error
    assert result["result"]["success"] is False
    assert result["result"]["error_code"] == "already_exists"


async def test_request_artist_success(
    hass: HomeAssistant, hass_ws_client, lidarr_entry
) -> None:
    """Successful artist request to Lidarr returns success=True."""
    with patch.object(
        ArrClient, "async_get_library_count", new_callable=AsyncMock, return_value=3
    ):
        with patch.object(
            ArrClient, "async_request_artist", new_callable=AsyncMock, return_value=None
        ):
            lidarr_entry.add_to_hass(hass)
            assert await hass.config_entries.async_setup(lidarr_entry.entry_id)
            await hass.async_block_till_done()
            client = await hass_ws_client(hass)
            await client.send_json(
                {
                    "id": 1,
                    "type": "requestarr/request_artist",
                    "foreign_artist_id": "a74b1b7f-71a5-4011-9441-d0b5e4122711",
                    "title": "Radiohead",
                }
            )
            result = await client.receive_json()

    assert result["success"] is True
    assert result["result"]["success"] is True
```

**File 4: tests/test_sensor.py**

Replace the scaffold test_sensor.py with focused tests for RequestarrSensor.

```python
"""Tests for Requestarr sensors."""

from unittest.mock import AsyncMock, patch

from homeassistant.core import HomeAssistant

from custom_components.requestarr.api import ArrClient


async def test_sensor_created_for_configured_services(
    hass: HomeAssistant, radarr_entry
) -> None:
    """Only sensors for configured services are created."""
    radarr_entry.add_to_hass(hass)
    with patch.object(
        ArrClient, "async_get_library_count", new_callable=AsyncMock, return_value=10
    ):
        assert await hass.config_entries.async_setup(radarr_entry.entry_id)
        await hass.async_block_till_done()

    # Radarr sensor should exist
    radarr_states = [
        k for k in hass.states.async_entity_ids("sensor")
        if "radarr" in k
    ]
    assert len(radarr_states) >= 1

    # Sonarr/Lidarr sensors should NOT exist (not configured)
    sonarr_states = [
        k for k in hass.states.async_entity_ids("sensor")
        if "sonarr" in k
    ]
    assert len(sonarr_states) == 0


async def test_sensor_library_count_attribute(
    hass: HomeAssistant, radarr_entry
) -> None:
    """Sensor has library_count attribute matching coordinator data."""
    radarr_entry.add_to_hass(hass)
    with patch.object(
        ArrClient, "async_get_library_count", new_callable=AsyncMock, return_value=42
    ):
        assert await hass.config_entries.async_setup(radarr_entry.entry_id)
        await hass.async_block_till_done()

    radarr_sensors = [
        k for k in hass.states.async_entity_ids("sensor")
        if "radarr" in k
    ]
    assert radarr_sensors
    state = hass.states.get(radarr_sensors[0])
    assert state is not None
    assert state.attributes.get("library_count") == 42
```

**File 5: README.md**

Replace the existing README with comprehensive documentation covering setup, features, and card configuration. Keep the existing badge/shield lines. The existing README has the right structure but needs more detail:

```markdown
# Requestarr

HA-native media request dashboard for Radarr, Sonarr, and Lidarr.

[![HACS Default](https://img.shields.io/badge/HACS-Default-blue.svg)](https://github.com/hacs/integration)
[![HA Version](https://img.shields.io/badge/Home%20Assistant-2025.7%2B-blue.svg)](https://www.home-assistant.io/)

Search for movies, TV shows, and music artists from a Home Assistant dashboard card and send requests directly to your arr stack — no separate app, no extra auth, no extra container.

## Features

- **Movies**: Search Radarr by title, request with one tap. "In Library" badge if already in Radarr.
- **TV**: Search Sonarr by title, request with one tap. "In Library" badge if already in Sonarr.
- **Music**: Search Lidarr by artist name, request with one tap. Circular avatar thumbnails (Spotify convention).
- All three services are optional — only configure what you have.
- Arr API keys stay server-side. Only public CDN image URLs (TMDB, TheTVDB, fanart.tv) reach the browser.

## Requirements

- Home Assistant 2025.7+
- At least one arr service: Radarr, Sonarr, and/or Lidarr
- HACS (for managed install) or manual file copy

## Installation via HACS

1. Open HACS in Home Assistant
2. Go to **Integrations**
3. Search for **Requestarr**
4. Click Install and restart Home Assistant

## Manual Installation

1. Copy `custom_components/requestarr/` into your HA `config/custom_components/`
2. Restart Home Assistant
3. Add the integration via **Settings → Devices & Services → Add Integration → Requestarr**

## Configuration

The setup wizard walks through three optional steps — Radarr, Sonarr, Lidarr. At least one must be configured.

For each service, provide:
- **URL** — e.g. `http://192.168.1.50:7878`
- **API Key** — from the arr service Settings → General → Security

Quality profiles, root folders, and (for Lidarr) metadata profiles are fetched automatically at setup time.

### Options

After setup, go to **Settings → Devices & Services → Requestarr → Configure** to:
- Change the default quality profile or root folder per service
- Toggle SSL verification
- Refresh profiles if you've changed them in the arr service

## Adding the Card

In your Lovelace dashboard, add a **Custom: Requestarr Card**:

```yaml
type: custom:requestarr-card
header: "Media Requests"
show_radarr: true
show_sonarr: true
show_lidarr: true
```

Or use the visual editor (click the pencil icon when editing a card).

### Card Options

| Option | Default | Description |
|--------|---------|-------------|
| `header` | `"Requestarr"` | Card title shown in the header |
| `show_radarr` | `true` | Show Movies tab (only if Radarr is configured) |
| `show_sonarr` | `true` | Show TV tab (only if Sonarr is configured) |
| `show_lidarr` | `true` | Show Music tab (only if Lidarr is configured) |

## Sensors

The integration creates library count sensors for each configured service:

- `sensor.requestarr_radarr` — Total movies in Radarr
- `sensor.requestarr_sonarr` — Total TV series in Sonarr
- `sensor.requestarr_lidarr` — Total artists in Lidarr

Sensors update every 5 minutes. The `library_count` attribute matches the sensor state.

## Links

- [Documentation](https://github.com/Dabentz/ha-requestarr)
- [Issues](https://github.com/Dabentz/ha-requestarr/issues)

## License

MIT
```

After writing all five files, run:
```bash
cd /home/dab/Projects/ha-requestarr && /home/dab/.local/bin/pytest tests/ -v --tb=short 2>&1 | tail -40
```

If any tests fail, read the error output carefully. Common issues:
- Import errors: check that the method names match the actual api.py (use `grep -n "async def" custom_components/requestarr/api.py`)
- Config flow step names: check actual step IDs in config_flow.py
- WS handler errors: check websocket.py imports and handler signatures
Fix the failing tests by reading the relevant source file and correcting the test. Do not change production code to make tests pass.
  </action>
  <verify>
cd /home/dab/Projects/ha-requestarr && /home/dab/.local/bin/pytest tests/ -v --tb=short 2>&1 | tail -20
  </verify>
  <done>
- All tests pass (exit code 0)
- test_config_flow.py tests Requestarr 3-step wizard (not scaffold patterns)
- test_coordinator.py tests RequestarrCoordinator (not TemplateCoordinator)
- test_websocket.py includes in_library detection test and already_exists error test
- test_sensor.py tests RequestarrSensor entity creation and library_count attribute
- conftest.py uses only Requestarr-specific config keys
- README.md documents all features, card options, and sensor entities
  </done>
</task>

</tasks>

<verification>
```bash
cd /home/dab/Projects/ha-requestarr && /home/dab/.local/bin/pytest tests/ -v 2>&1 | tail -20
```

All tests should pass. Confirm no tests reference TemplateCoordinator, ApiClient.async_get_data, CONF_HOST, or CONF_PORT:
```bash
grep -r "TemplateCoordinator\|async_get_data\|CONF_HOST\|CONF_PORT" /home/dab/Projects/ha-requestarr/tests/ 2>/dev/null || echo "CLEAN"
```
</verification>

<success_criteria>
- `pytest tests/ -v` exits 0 with all tests passing
- No scaffold-era patterns remain in test files (TemplateCoordinator, ApiClient.async_get_data, CONF_HOST, CONF_PORT)
- conftest.py imports from custom_components.requestarr.const exclusively (not homeassistant.const)
- test_websocket.py has at least one test asserting in_library=True when arr id > 0
- test_coordinator.py has partial failure test asserting coordinator tolerates one service down
- README.md has card configuration section documenting show_radarr/show_sonarr/show_lidarr options
</success_criteria>

<output>
After completion, create `.planning/phases/05-library-state-card-polish-validation/05-02-SUMMARY.md`
</output>
