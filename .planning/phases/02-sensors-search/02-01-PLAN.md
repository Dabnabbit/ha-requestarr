---
phase: 02-sensors-search
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - custom_components/requestarr/const.py
  - custom_components/requestarr/api.py
  - custom_components/requestarr/coordinator.py
  - custom_components/requestarr/sensor.py
  - custom_components/requestarr/websocket.py
  - custom_components/requestarr/strings.json
  - custom_components/requestarr/translations/en.json
autonomous: true
requirements: [SENS-01, SENS-02, SENS-03, SRCH-01, SRCH-02, SRCH-03, SRCH-04, SRCH-05]

must_haves:
  truths:
    - Each configured arr service has a sensor showing connected/disconnected/error status with library count as attribute
    - Movie search WebSocket command returns Radarr lookup results with TMDB CDN poster URLs (w300)
    - TV search WebSocket command returns Sonarr lookup results with TheTVDB CDN poster URLs
    - Music search WebSocket command returns Lidarr lookup results with fanart.tv CDN image URLs
    - Arr API keys never appear in any WebSocket response payload
    - Search results include in_library boolean, arr_id, external IDs, and default profile/folder info
    - Unconfigured services return service_not_configured error, not crash
  artifacts:
    - custom_components/requestarr/sensor.py with RequestarrSensor class
    - custom_components/requestarr/websocket.py with search_movies, search_tv, search_music commands
    - custom_components/requestarr/api.py with async_search method on ArrClient
    - custom_components/requestarr/const.py with LOOKUP_ENDPOINTS and WS_TYPE constants
  key_links:
    - sensor.py imports RequestarrCoordinator (not TemplateCoordinator) and reads coordinator.data
    - websocket.py looks up config entry fresh on each call (no stale references)
    - api.py async_search uses LOOKUP_ENDPOINTS keyed by service_type
    - Image URLs use remoteUrl/remotePoster fields (public CDN), never MediaCoverProxy URLs
---

<objective>
Implement library count sensors and WebSocket search commands for all configured arr services.

Purpose: Expose library stats in HA and enable media search from the Lovelace card via arr lookup endpoints.
Output: Sensors visible in HA dashboard; WebSocket commands returning normalized search results with public CDN image URLs.
</objective>

<execution_context>
@/home/dab/.claude/get-shit-done/workflows/execute-plan.md
@/home/dab/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-sensors-search/02-RESEARCH.md
@.planning/research/ARR_LOOKUP_API.md

<interfaces>
<!-- Key types and contracts from Phase 1 codebase. Executor should use these directly. -->

From custom_components/requestarr/const.py:
```python
DOMAIN = "requestarr"
DEFAULT_TIMEOUT = 10
DEFAULT_SCAN_INTERVAL = 300
SERVICE_RADARR = "radarr"
SERVICE_SONARR = "sonarr"
SERVICE_LIDARR = "lidarr"
ARR_SERVICES = [SERVICE_RADARR, SERVICE_SONARR, SERVICE_LIDARR]
API_VERSIONS = {SERVICE_RADARR: "v3", SERVICE_SONARR: "v3", SERVICE_LIDARR: "v1"}
LIBRARY_ENDPOINTS = {SERVICE_RADARR: "/movie", SERVICE_SONARR: "/series", SERVICE_LIDARR: "/artist"}
# Config keys: CONF_{RADARR,SONARR,LIDARR}_{URL,API_KEY,VERIFY_SSL,QUALITY_PROFILE_ID,ROOT_FOLDER,PROFILES,FOLDERS}
# Lidarr extras: CONF_LIDARR_METADATA_PROFILE_ID, CONF_LIDARR_METADATA_PROFILES
FRONTEND_SCRIPT_URL = f"/{DOMAIN}/{DOMAIN}-card.js"
```

From custom_components/requestarr/api.py:
```python
class CannotConnectError(Exception): ...
class InvalidAuthError(Exception): ...
class ServerError(Exception): ...

class ArrClient:
    def __init__(self, base_url, api_key, service_type, session, verify_ssl=True, timeout=DEFAULT_TIMEOUT): ...
    async def _request(self, method, endpoint, **kwargs) -> Any: ...
    async def async_validate_connection(self) -> bool: ...
    async def async_get_quality_profiles(self) -> list[dict]: ...
    async def async_get_root_folders(self) -> list[dict]: ...
    async def async_get_metadata_profiles(self) -> list[dict]: ...
    async def async_get_library_count(self) -> int: ...
```

From custom_components/requestarr/coordinator.py:
```python
class RequestarrCoordinator(DataUpdateCoordinator[dict[str, Any]]):
    config_entry: ConfigEntry
    _clients: dict[str, ArrClient]  # keyed by service_type

    @property
    def configured_services(self) -> list[str]: ...  # returns list of service_type strings

    async def _async_update_data(self) -> dict[str, Any]:
        # Returns: {"{service}_count": int|None, "errors": {service: str}}
```

From custom_components/requestarr/__init__.py:
```python
@dataclass
class RequestarrData:
    coordinator: RequestarrCoordinator

type RequestarrConfigEntry = ConfigEntry[RequestarrData]

PLATFORMS: list[Platform] = [Platform.SENSOR, Platform.BINARY_SENSOR]
# async_setup registers static paths and websocket commands
# async_setup_entry creates coordinator, stores in runtime_data, forwards platforms
```

From custom_components/requestarr/websocket.py (current template):
```python
WS_TYPE_GET_DATA = f"{DOMAIN}/get_data"

def async_setup_websocket(hass): ...
async def websocket_get_data(hass, connection, msg): ...
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add lookup constants and search method to ArrClient</name>
  <files>
    custom_components/requestarr/const.py
    custom_components/requestarr/api.py
    custom_components/requestarr/coordinator.py
  </files>
  <action>
**const.py** — Add these constants:

```python
# Lookup (search) endpoints per service
LOOKUP_ENDPOINTS: dict[str, str] = {
    SERVICE_RADARR: "/movie/lookup",
    SERVICE_SONARR: "/series/lookup",
    SERVICE_LIDARR: "/artist/lookup",
}

# WebSocket command types
WS_TYPE_SEARCH_MOVIES = f"{DOMAIN}/search_movies"
WS_TYPE_SEARCH_TV = f"{DOMAIN}/search_tv"
WS_TYPE_SEARCH_MUSIC = f"{DOMAIN}/search_music"

# Search limits
MAX_SEARCH_RESULTS = 20
```

**api.py** — Add `async_search` method to `ArrClient`. Import `LOOKUP_ENDPOINTS` alongside existing imports:

```python
async def async_search(self, query: str) -> list[dict[str, Any]]:
    """Search the arr service's lookup endpoint.

    Args:
        query: Search term.

    Returns:
        List of raw result dicts from the arr API.
    """
    endpoint = LOOKUP_ENDPOINTS[self._service_type]
    return await self._request("GET", endpoint, params={"term": query})
```

**coordinator.py** — Enhance `_async_update_data` to track last successful sync time per service. Import `from homeassistant.util import dt as dt_util`. In the update loop, when a service succeeds, set `data[f"{service_type}_last_sync"] = dt_util.utcnow().isoformat()`. When a service fails, preserve the previous last_sync from `self.data` (if exists).

Also expose a method to get the ArrClient for a service type (needed by WebSocket handlers):

```python
def get_client(self, service_type: str) -> ArrClient | None:
    """Return the ArrClient for a service type, or None if not configured."""
    return self._clients.get(service_type)
```
  </action>
  <verify>
    <automated>cd /home/dab/Projects/ha-requestarr && python -c "
from custom_components.requestarr.const import LOOKUP_ENDPOINTS, WS_TYPE_SEARCH_MOVIES, WS_TYPE_SEARCH_TV, WS_TYPE_SEARCH_MUSIC, MAX_SEARCH_RESULTS
from custom_components.requestarr.api import ArrClient
assert hasattr(ArrClient, 'async_search'), 'ArrClient missing async_search'
assert LOOKUP_ENDPOINTS['radarr'] == '/movie/lookup'
assert LOOKUP_ENDPOINTS['sonarr'] == '/series/lookup'
assert LOOKUP_ENDPOINTS['lidarr'] == '/artist/lookup'
assert MAX_SEARCH_RESULTS == 20
print('Task 1 verified')
"</automated>
  </verify>
  <done>
    - LOOKUP_ENDPOINTS dict has entries for all three service types
    - WS_TYPE constants defined for search_movies, search_tv, search_music
    - MAX_SEARCH_RESULTS = 20
    - ArrClient has async_search method using LOOKUP_ENDPOINTS
    - RequestarrCoordinator tracks last_sync timestamps and exposes get_client()
  </done>
</task>

<task type="auto">
  <name>Task 2: Replace template sensors with conditional service status sensors</name>
  <files>
    custom_components/requestarr/sensor.py
    custom_components/requestarr/strings.json
    custom_components/requestarr/translations/en.json
  </files>
  <action>
**sensor.py** — Replace the entire template content. Build conditional sensors — one per configured service:

1. Import from the correct modules (NOT `TemplateCoordinator`):
```python
from . import RequestarrConfigEntry
from .const import (
    CONF_RADARR_URL, CONF_SONARR_URL, CONF_LIDARR_URL,
    DOMAIN, SERVICE_RADARR, SERVICE_SONARR, SERVICE_LIDARR,
)
from .coordinator import RequestarrCoordinator
```

2. Define sensor config per service type:
```python
SERVICE_SENSOR_CONFIG: dict[str, dict[str, str]] = {
    SERVICE_RADARR: {
        "name": "Radarr",
        "icon": "mdi:movie",
        "url_key": CONF_RADARR_URL,
    },
    SERVICE_SONARR: {
        "name": "Sonarr",
        "icon": "mdi:television",
        "url_key": CONF_SONARR_URL,
    },
    SERVICE_LIDARR: {
        "name": "Lidarr",
        "icon": "mdi:music",
        "url_key": CONF_LIDARR_URL,
    },
}
```

3. `async_setup_entry`: Only create sensors for services in `coordinator.configured_services`:
```python
async def async_setup_entry(
    hass: HomeAssistant,
    entry: RequestarrConfigEntry,
    async_add_entities: AddEntitiesCallback,
) -> None:
    coordinator = entry.runtime_data.coordinator
    entities: list[RequestarrSensor] = []
    for service_type in coordinator.configured_services:
        entities.append(RequestarrSensor(coordinator, entry, service_type))
    async_add_entities(entities)
```

4. `RequestarrSensor` class extending `CoordinatorEntity[RequestarrCoordinator]` and `SensorEntity`:
   - `_attr_has_entity_name = True`
   - `unique_id`: `f"{entry.entry_id}_{service_type}"`
   - `name`: from `SERVICE_SENSOR_CONFIG[service_type]["name"]`
   - `icon`: from `SERVICE_SENSOR_CONFIG[service_type]["icon"]`
   - `device_info`: `DeviceInfo(identifiers={(DOMAIN, entry.entry_id)}, entry_type=DeviceEntryType.SERVICE, name="Requestarr", manufacturer="Requestarr")`
   - `native_value` property:
     - If `self.coordinator.data` is None: return None
     - Check `self.coordinator.data.get("errors", {})`: if `self._service_type` in errors, return `"error"`
     - Get count from `self.coordinator.data.get(f"{self._service_type}_count")`: if None return `"disconnected"`, else return `"connected"`
   - `extra_state_attributes` property returns dict with:
     - `"library_count"`: from coordinator data `{service_type}_count`
     - `"service_url"`: masked URL — take the URL from config entry data, mask it by showing only scheme + host (replace path/query with nothing, keep `http://hostname:port` but redact the rest). Use a simple approach: `url.split("/api")[0]` or just store the base URL as-is since it has no secrets (only the API key is secret, and it's not in the URL).
     - `"last_successful_sync"`: from coordinator data `{service_type}_last_sync`

5. Keep `PARALLEL_UPDATES = 0`.

**strings.json** — Ensure sensor entity name translations exist. Add under `"entity"` key:
```json
{
  "entity": {
    "sensor": {
      "radarr": {"name": "Radarr"},
      "sonarr": {"name": "Sonarr"},
      "lidarr": {"name": "Lidarr"}
    }
  }
}
```

Merge with existing strings.json content (config flow strings already exist from Phase 1).

**translations/en.json** — Mirror the same entity translations. Merge with existing content.
  </action>
  <verify>
    <automated>cd /home/dab/Projects/ha-requestarr && python -c "
from custom_components.requestarr.sensor import RequestarrSensor, SERVICE_SENSOR_CONFIG, async_setup_entry
from custom_components.requestarr.const import SERVICE_RADARR, SERVICE_SONARR, SERVICE_LIDARR
assert SERVICE_RADARR in SERVICE_SENSOR_CONFIG
assert SERVICE_SONARR in SERVICE_SENSOR_CONFIG
assert SERVICE_LIDARR in SERVICE_SENSOR_CONFIG
assert SERVICE_SENSOR_CONFIG[SERVICE_RADARR]['icon'] == 'mdi:movie'
assert SERVICE_SENSOR_CONFIG[SERVICE_SONARR]['icon'] == 'mdi:television'
assert SERVICE_SENSOR_CONFIG[SERVICE_LIDARR]['icon'] == 'mdi:music'
print('Task 2 verified')
"</automated>
  </verify>
  <done>
    - sensor.py creates one sensor per configured service (not for unconfigured ones)
    - Sensor state is connected/disconnected/error (not a count)
    - Attributes include library_count, service_url, last_successful_sync
    - Icons: mdi:movie (Radarr), mdi:television (Sonarr), mdi:music (Lidarr)
    - No reference to TemplateCoordinator or TemplateSensor
    - strings.json and translations/en.json updated with entity names
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement search WebSocket commands with result normalization</name>
  <files>
    custom_components/requestarr/websocket.py
  </files>
  <action>
Replace the template websocket.py with full search implementation. Keep the existing `get_data` command for backward compatibility, and add three search commands.

1. **Import constants and types:**
```python
from .const import (
    CONF_RADARR_QUALITY_PROFILE_ID, CONF_RADARR_ROOT_FOLDER, CONF_RADARR_PROFILES, CONF_RADARR_FOLDERS,
    CONF_SONARR_QUALITY_PROFILE_ID, CONF_SONARR_ROOT_FOLDER, CONF_SONARR_PROFILES, CONF_SONARR_FOLDERS,
    CONF_LIDARR_QUALITY_PROFILE_ID, CONF_LIDARR_ROOT_FOLDER, CONF_LIDARR_PROFILES, CONF_LIDARR_FOLDERS,
    DOMAIN, MAX_SEARCH_RESULTS,
    SERVICE_RADARR, SERVICE_SONARR, SERVICE_LIDARR,
    WS_TYPE_SEARCH_MOVIES, WS_TYPE_SEARCH_TV, WS_TYPE_SEARCH_MUSIC,
)
from .api import CannotConnectError, InvalidAuthError, ServerError
```

2. **Helper: get coordinator from config entries:**
```python
def _get_coordinator(hass):
    entries = hass.config_entries.async_entries(DOMAIN)
    if not entries:
        return None
    return entries[0].runtime_data.coordinator
```

3. **Helper: get config entry data:**
```python
def _get_config_data(hass):
    entries = hass.config_entries.async_entries(DOMAIN)
    if not entries:
        return {}
    return dict(entries[0].data)
```

4. **Result normalization functions** (three separate functions for clarity):

`_normalize_movie_result(item, config_data)`:
- `title`: `item.get("title", "")`
- `year`: `item.get("year")`
- `overview`: `item.get("overview", "")` -- full text, card handles truncation
- `poster_url`: Extract from `item.get("remotePoster")`, fallback to `images` array finding `coverType == "poster"` and using `remoteUrl`. If URL contains `image.tmdb.org/t/p/original`, replace with `/t/p/w300/`.
- `in_library`: `item.get("id", 0) > 0`
- `arr_id`: `item.get("id")` if > 0, else None
- `tmdb_id`: `item.get("tmdbId")`
- `quality_profile`: Look up profile name from `config_data.get(CONF_RADARR_PROFILES, [])` by matching ID == `config_data.get(CONF_RADARR_QUALITY_PROFILE_ID)`. If no match, return empty string.
- `root_folder`: `config_data.get(CONF_RADARR_ROOT_FOLDER, "")`

`_normalize_tv_result(item, config_data)`:
- Same pattern as movie but:
- `tvdb_id`: `item.get("tvdbId")` instead of tmdb_id
- TheTVDB poster URLs: no rewriting needed, pass through as-is
- Profile/folder from Sonarr config keys

`_normalize_music_result(item, config_data)`:
- `title`: `item.get("artistName", "")`
- `year`: None (artists don't have a single year)
- `overview`: `item.get("overview", "")`
- `poster_url`: Extract from `item.get("remotePoster")`, fallback to `images` array finding `coverType == "poster"` and using `remoteUrl`. Fanart.tv URLs: no rewriting needed, pass through as-is.
- `in_library`: `item.get("id", 0) > 0`
- `arr_id`: `item.get("id")` if > 0, else None
- `foreign_artist_id`: `item.get("foreignArtistId")`
- Profile/folder from Lidarr config keys

5. **Generic search handler factory** to avoid code duplication:

```python
async def _handle_search(
    hass, connection, msg, service_type, normalize_fn,
):
    """Generic search handler for all arr services."""
    query = msg["query"].strip()
    if not query:
        connection.send_result(msg["id"], {
            "error": "invalid_query",
            "message": "Search query cannot be empty",
            "results": [],
        })
        return

    coordinator = _get_coordinator(hass)
    if coordinator is None:
        connection.send_error(msg["id"], "not_found", "Requestarr not configured")
        return

    client = coordinator.get_client(service_type)
    if client is None:
        connection.send_result(msg["id"], {
            "error": "service_not_configured",
            "message": f"{service_type.title()} is not configured in Requestarr",
            "results": [],
        })
        return

    config_data = _get_config_data(hass)

    try:
        raw_results = await client.async_search(query)
    except (CannotConnectError, InvalidAuthError, ServerError) as err:
        connection.send_result(msg["id"], {
            "error": "service_unavailable",
            "message": f"{service_type.title()} is unavailable: {err}",
            "results": [],
        })
        return

    results = [normalize_fn(item, config_data) for item in raw_results[:MAX_SEARCH_RESULTS]]
    connection.send_result(msg["id"], {"results": results})
```

6. **Three WebSocket command handlers** (one per media type):

```python
@websocket_api.websocket_command({
    vol.Required("type"): WS_TYPE_SEARCH_MOVIES,
    vol.Required("query"): str,
})
@websocket_api.async_response
async def websocket_search_movies(hass, connection, msg):
    await _handle_search(hass, connection, msg, SERVICE_RADARR, _normalize_movie_result)

@websocket_api.websocket_command({
    vol.Required("type"): WS_TYPE_SEARCH_TV,
    vol.Required("query"): str,
})
@websocket_api.async_response
async def websocket_search_tv(hass, connection, msg):
    await _handle_search(hass, connection, msg, SERVICE_SONARR, _normalize_tv_result)

@websocket_api.websocket_command({
    vol.Required("type"): WS_TYPE_SEARCH_MUSIC,
    vol.Required("query"): str,
})
@websocket_api.async_response
async def websocket_search_music(hass, connection, msg):
    await _handle_search(hass, connection, msg, SERVICE_LIDARR, _normalize_music_result)
```

7. **Update `async_setup_websocket`** to register all four commands (keep existing get_data + three new search commands):
```python
@callback
def async_setup_websocket(hass):
    websocket_api.async_register_command(hass, websocket_get_data)
    websocket_api.async_register_command(hass, websocket_search_movies)
    websocket_api.async_register_command(hass, websocket_search_tv)
    websocket_api.async_register_command(hass, websocket_search_music)
```

**CRITICAL SECURITY CHECK:** Verify that NO response payload contains:
- arr API keys
- arr base URLs with /api/ paths
- MediaCoverProxy URLs (which require API key to fetch)

Only public CDN URLs (image.tmdb.org, artworks.thetvdb.com, assets.fanart.tv, coverartarchive.org) should appear in poster_url fields.
  </action>
  <verify>
    <automated>cd /home/dab/Projects/ha-requestarr && python -c "
from custom_components.requestarr.websocket import (
    websocket_search_movies, websocket_search_tv, websocket_search_music,
    websocket_get_data, async_setup_websocket,
    _normalize_movie_result, _normalize_tv_result, _normalize_music_result,
)
# Verify normalization strips TMDB original to w300
test_movie = {'title': 'Test', 'year': 2024, 'overview': 'A test', 'id': 0, 'tmdbId': 123,
              'remotePoster': 'https://image.tmdb.org/t/p/original/abc.jpg', 'images': []}
result = _normalize_movie_result(test_movie, {})
assert result['poster_url'] == 'https://image.tmdb.org/t/p/w300/abc.jpg', f'Expected w300, got {result[\"poster_url\"]}'
assert result['in_library'] == False
assert result['tmdb_id'] == 123
assert result['arr_id'] is None

# Verify in_library detection
test_movie_lib = {**test_movie, 'id': 42}
result_lib = _normalize_movie_result(test_movie_lib, {})
assert result_lib['in_library'] == True
assert result_lib['arr_id'] == 42

# Verify TV normalization passes TheTVDB URLs through
test_tv = {'title': 'Test Show', 'year': 2024, 'overview': 'A show', 'id': 0, 'tvdbId': 456,
           'remotePoster': 'https://artworks.thetvdb.com/banners/posters/456.jpg', 'images': []}
result_tv = _normalize_tv_result(test_tv, {})
assert 'thetvdb.com' in result_tv['poster_url']
assert result_tv['tvdb_id'] == 456

# Verify music normalization uses artistName
test_artist = {'artistName': 'Test Artist', 'overview': 'Bio', 'id': 0,
               'foreignArtistId': 'abc-123', 'remotePoster': 'https://assets.fanart.tv/fanart/music/poster.jpg', 'images': []}
result_music = _normalize_music_result(test_artist, {})
assert result_music['title'] == 'Test Artist'
assert result_music['foreign_artist_id'] == 'abc-123'

print('Task 3 verified')
"</automated>
  </verify>
  <done>
    - Three WebSocket search commands registered: search_movies, search_tv, search_music
    - Each validates query (rejects empty with invalid_query error)
    - Each checks service configuration (returns service_not_configured if missing)
    - Each handles connection errors (returns service_unavailable)
    - Results capped at 20 per query
    - TMDB poster URLs rewritten from /original/ to /w300/
    - TheTVDB and fanart.tv URLs passed through unchanged
    - Every result includes: title, year, overview, poster_url, in_library, arr_id, external IDs, quality_profile, root_folder
    - No API keys or arr service URLs in response payloads
    - Existing get_data command preserved
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Import check: `python -c "from custom_components.requestarr import sensor, websocket, api, coordinator, const"` succeeds
2. Sensor class uses RequestarrCoordinator (not TemplateCoordinator): grep confirms no "TemplateCoordinator" or "TemplateSensor" in sensor.py
3. WebSocket commands registered: websocket.py defines all four WS_TYPE constants and handlers
4. No API key leakage: grep the entire websocket.py for "api_key" -- should only appear in import of error classes, never in response payloads
5. Image URL safety: grep websocket.py for "MediaCoverProxy" -- should return zero matches (never use proxy URLs)
</verification>

<success_criteria>
- All three sensor entities creatable for configured services (conditional on coordinator.configured_services)
- Sensor state: connected/disconnected/error (not numeric)
- Sensor attributes: library_count, service_url, last_successful_sync
- Three WebSocket search commands work end-to-end: query -> arr lookup -> normalize -> respond
- Error codes: service_not_configured, service_unavailable, invalid_query
- Results capped at 20, TMDB images downsized to w300
- No secrets (API keys, internal URLs) leak to frontend
</success_criteria>

<output>
After completion, create `.planning/phases/02-sensors-search/02-01-SUMMARY.md`
</output>
