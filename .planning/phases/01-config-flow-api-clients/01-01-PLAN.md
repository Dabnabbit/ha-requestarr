---
phase: 01-config-flow-api-clients
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - custom_components/requestarr/const.py
  - custom_components/requestarr/api.py
  - custom_components/requestarr/config_flow.py
  - custom_components/requestarr/coordinator.py
  - custom_components/requestarr/__init__.py
  - custom_components/requestarr/strings.json
  - custom_components/requestarr/translations/en.json
autonomous: true
requirements:
  - CONF-01
  - CONF-02
  - CONF-03
  - CONF-04
  - CONF-05
  - SENS-04

must_haves:
  truths:
    - "User can configure Radarr URL and API key with live validation against /api/v3/system/status"
    - "User can configure Sonarr URL and API key with live validation against /api/v3/system/status"
    - "User can configure Lidarr URL and API key with live validation against /api/v1/system/status"
    - "User can skip any individual arr service but at least one must be configured"
    - "Quality profiles and root folders are fetched from each configured service at config time"
    - "Lidarr metadata profiles are fetched at config time in addition to quality profiles and root folders"
    - "Coordinator polls library counts from all configured services every 5 minutes"
    - "If one service is unavailable during polling, other services still update normally"
  artifacts:
    - path: "custom_components/requestarr/const.py"
      provides: "All CONF_ constants, arr API path constants, service type definitions"
      contains: "CONF_RADARR_URL"
    - path: "custom_components/requestarr/api.py"
      provides: "Uniform ArrClient class for all arr services"
      exports: ["ArrClient", "CannotConnectError", "InvalidAuthError"]
    - path: "custom_components/requestarr/config_flow.py"
      provides: "3-step config wizard + options flow + reconfigure flow"
      contains: "async_step_radarr"
    - path: "custom_components/requestarr/coordinator.py"
      provides: "DataUpdateCoordinator polling library counts with partial failure tolerance"
      contains: "_async_update_data"
    - path: "custom_components/requestarr/__init__.py"
      provides: "Integration setup wiring coordinator and clients into runtime_data"
      contains: "RequestarrData"
    - path: "custom_components/requestarr/strings.json"
      provides: "UI strings for 3-step config flow"
      contains: "radarr"
    - path: "custom_components/requestarr/translations/en.json"
      provides: "English translations mirroring strings.json"
      contains: "radarr"
  key_links:
    - from: "custom_components/requestarr/config_flow.py"
      to: "custom_components/requestarr/api.py"
      via: "ArrClient instantiation for live validation"
      pattern: "ArrClient\\("
    - from: "custom_components/requestarr/coordinator.py"
      to: "custom_components/requestarr/api.py"
      via: "ArrClient instances for polling"
      pattern: "ArrClient\\("
    - from: "custom_components/requestarr/__init__.py"
      to: "custom_components/requestarr/coordinator.py"
      via: "RequestarrCoordinator instantiation in async_setup_entry"
      pattern: "RequestarrCoordinator\\("
    - from: "custom_components/requestarr/config_flow.py"
      to: "custom_components/requestarr/strings.json"
      via: "step_id names must match strings.json keys"
      pattern: "step_id=\"radarr\""
---

<objective>
Build the uniform arr API client and 3-step config flow with live validation, profile fetching, options flow, reconfigure flow, and coordinator polling library counts with partial failure tolerance.

Purpose: This is the foundation — users must be able to set up the integration and validate their arr service connections before any sensors, search, or request features can work.
Output: Working config flow that validates connections, fetches profiles, and a coordinator that polls library counts every 5 minutes.
</objective>

<execution_context>
@/home/dab/.claude/get-shit-done/workflows/execute-plan.md
@/home/dab/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-config-flow-api-clients/01-CONTEXT.md
@.planning/phases/01-config-flow-api-clients/01-RESEARCH.md

<interfaces>
<!-- Existing template code that will be replaced. Key patterns to preserve: -->

From custom_components/requestarr/__init__.py:
```python
# Keep these imports and patterns:
from homeassistant.components.http import StaticPathConfig, async_register_static_paths
from homeassistant.config_entries import ConfigEntry
from homeassistant.core import HomeAssistant
from .coordinator import TemplateCoordinator  # Will become RequestarrCoordinator
from .websocket import async_setup_websocket
from .services import async_register_services

# Keep the RequestarrData dataclass pattern (rename coordinator type)
# Keep async_setup() with static path registration, websocket setup, services
# Keep async_setup_entry() with coordinator first refresh
# Keep async_unload_entry()
# Keep PLATFORMS = [Platform.SENSOR, Platform.BINARY_SENSOR]
# Keep type RequestarrConfigEntry = ConfigEntry[RequestarrData]
```

From custom_components/requestarr/manifest.json:
```json
{
  "domain": "requestarr",
  "name": "Requestarr",
  "dependencies": ["frontend", "http", "websocket_api"],
  "iot_class": "cloud_polling",
  "requirements": []
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define constants and build uniform ArrClient</name>
  <files>custom_components/requestarr/const.py, custom_components/requestarr/api.py</files>
  <action>
**const.py** — Replace the entire file with Requestarr-specific constants:

```python
DOMAIN = "requestarr"

# Timeouts
DEFAULT_TIMEOUT = 10  # 10-second connection timeout per user decision
DEFAULT_SCAN_INTERVAL = 300  # 5 minutes in seconds

# Arr service types
SERVICE_RADARR = "radarr"
SERVICE_SONARR = "sonarr"
SERVICE_LIDARR = "lidarr"
ARR_SERVICES = [SERVICE_RADARR, SERVICE_SONARR, SERVICE_LIDARR]

# API versions per service
API_VERSIONS = {
    SERVICE_RADARR: "v3",
    SERVICE_SONARR: "v3",
    SERVICE_LIDARR: "v1",
}

# Library count endpoints per service
LIBRARY_ENDPOINTS = {
    SERVICE_RADARR: "/movie",
    SERVICE_SONARR: "/series",
    SERVICE_LIDARR: "/artist",
}

# Config keys — per-service URL and API key
CONF_RADARR_URL = "radarr_url"
CONF_RADARR_API_KEY = "radarr_api_key"
CONF_RADARR_VERIFY_SSL = "radarr_verify_ssl"
CONF_RADARR_QUALITY_PROFILE_ID = "radarr_quality_profile_id"
CONF_RADARR_ROOT_FOLDER = "radarr_root_folder"
CONF_RADARR_PROFILES = "radarr_profiles"
CONF_RADARR_FOLDERS = "radarr_folders"

CONF_SONARR_URL = "sonarr_url"
CONF_SONARR_API_KEY = "sonarr_api_key"
CONF_SONARR_VERIFY_SSL = "sonarr_verify_ssl"
CONF_SONARR_QUALITY_PROFILE_ID = "sonarr_quality_profile_id"
CONF_SONARR_ROOT_FOLDER = "sonarr_root_folder"
CONF_SONARR_PROFILES = "sonarr_profiles"
CONF_SONARR_FOLDERS = "sonarr_folders"

CONF_LIDARR_URL = "lidarr_url"
CONF_LIDARR_API_KEY = "lidarr_api_key"
CONF_LIDARR_VERIFY_SSL = "lidarr_verify_ssl"
CONF_LIDARR_QUALITY_PROFILE_ID = "lidarr_quality_profile_id"
CONF_LIDARR_ROOT_FOLDER = "lidarr_root_folder"
CONF_LIDARR_METADATA_PROFILE_ID = "lidarr_metadata_profile_id"
CONF_LIDARR_PROFILES = "lidarr_profiles"
CONF_LIDARR_FOLDERS = "lidarr_folders"
CONF_LIDARR_METADATA_PROFILES = "lidarr_metadata_profiles"

# Frontend
FRONTEND_SCRIPT_URL = f"/{DOMAIN}/{DOMAIN}-card.js"
```

**api.py** — Replace with a uniform ArrClient class:

- Single class handling Radarr (v3), Sonarr (v3), Lidarr (v1) through a `service_type` parameter
- Constructor: `(base_url: str, api_key: str, service_type: str, session: aiohttp.ClientSession, verify_ssl: bool = True, timeout: int = DEFAULT_TIMEOUT)`
- `base_url` is the user-entered URL (e.g., `http://192.168.1.50:7878`), client appends `/api/{version}/`
- Strip trailing slashes from base_url in constructor
- Auth via `X-Api-Key` header on all requests
- SSL: pass `ssl=None` if verify_ssl is True (default aiohttp behavior), `ssl=False` if verify_ssl is False
- Methods:
  - `_request(method, endpoint, **kwargs) -> Any` — core request method, raises CannotConnectError or InvalidAuthError
  - `async_validate_connection() -> bool` — GET `/system/status`, returns True or raises
  - `async_get_quality_profiles() -> list[dict]` — GET `/qualityprofile`
  - `async_get_root_folders() -> list[dict]` — GET `/rootfolder`
  - `async_get_metadata_profiles() -> list[dict]` — GET `/metadataprofile` (Lidarr only)
  - `async_get_library_count() -> int` — GET the library endpoint, return len(result)
- Keep existing exception classes: CannotConnectError, InvalidAuthError, ServerError
- Error handling: catch `aiohttp.ClientConnectionError`, `aiohttp.ClientError`, `asyncio.TimeoutError` -> CannotConnectError; HTTP 401/403 -> InvalidAuthError; HTTP 4xx/5xx -> ServerError
- Use `aiohttp.ClientTimeout(total=timeout)` for timeout control
- DO NOT create own aiohttp session — receive it from caller

Important: The `_request` method should handle the response body. If the response body is empty (e.g., for `/system/status` on some arr versions), return `{}` instead of crashing on JSON decode. Use `resp.text()` first to check if non-empty before calling `resp.json()`.
  </action>
  <verify>
    <automated>cd /home/dab/Projects/ha-requestarr && python3 -c "from custom_components.requestarr.const import DOMAIN, CONF_RADARR_URL, API_VERSIONS, LIBRARY_ENDPOINTS; from custom_components.requestarr.api import ArrClient, CannotConnectError, InvalidAuthError; print('OK')"</automated>
  </verify>
  <done>
- const.py contains all CONF_ constants for all three arr services
- api.py exports ArrClient with validate_connection, get_quality_profiles, get_root_folders, get_metadata_profiles, get_library_count
- ArrClient handles v3 (Radarr/Sonarr) and v1 (Lidarr) API versions automatically
- SSL verification toggle works via verify_ssl parameter
- 10-second timeout by default
  </done>
</task>

<task type="auto">
  <name>Task 2: Build 3-step config flow with options and reconfigure</name>
  <files>custom_components/requestarr/config_flow.py, custom_components/requestarr/strings.json, custom_components/requestarr/translations/en.json</files>
  <action>
**config_flow.py** — Complete rewrite of the config flow:

**Class: RequestarrConfigFlow(ConfigFlow, domain=DOMAIN):**
- VERSION = 1
- `__init__`: Initialize `self._data: dict[str, Any] = {}`
- Static method `async_get_options_flow` returning `RequestarrOptionsFlowHandler()`

**Steps (3-step wizard: Radarr -> Sonarr -> Lidarr):**

Each step follows this pattern:
1. Show form with: URL field (str), API key field (str), Verify SSL checkbox (bool, default True), Skip checkbox (bool, default False)
2. If skip checked: store nothing for this service, advance to next step
3. If not skipped: strip trailing slashes from URL, validate URL is not empty, validate API key is not empty
4. Create ArrClient with `async_get_clientsession(self.hass)`, call `async_validate_connection()`
5. On success: fetch quality profiles + root folders (+ metadata profiles for Lidarr)
6. Store URL, API key, verify_ssl, profiles list (id+name dicts), folders list (id+path dicts), default profile ID, default root folder path
7. For default profile: use first profile in the returned list (arr services don't have isDefault field)
8. For default folder: use first folder's path
9. Advance to next step

**async_step_radarr(user_input):**
- Schema: `{vol.Optional(CONF_RADARR_URL, default=""): str, vol.Optional(CONF_RADARR_API_KEY, default=""): str, vol.Optional(CONF_RADARR_VERIFY_SSL, default=True): bool, vol.Optional("skip_radarr", default=False): bool}`
- On success or skip: `return await self.async_step_sonarr()`
- Errors: `{CONF_RADARR_URL: "cannot_connect"}` or `{CONF_RADARR_API_KEY: "invalid_auth"}` or `{"base": "cannot_fetch_profiles"}`
- description_placeholders: `{"url_example": "http://192.168.1.50:7878"}`

**async_step_sonarr(user_input):**
- Same pattern as Radarr but with CONF_SONARR_* constants
- On success or skip: `return await self.async_step_lidarr()`
- description_placeholders: `{"url_example": "http://192.168.1.50:8989"}`

**async_step_lidarr(user_input):**
- Same pattern but with CONF_LIDARR_* constants AND metadata profile fetch
- Also fetch `async_get_metadata_profiles()` and store as CONF_LIDARR_METADATA_PROFILES
- Select default metadata profile (first in list)
- CRITICAL: Before advancing, check if ANY service was configured (has URL stored in self._data). If none configured and user tries to skip, set `errors["base"] = "no_services"` and re-show form
- On success: set unique_id to DOMAIN (singleton integration), call `self._abort_if_unique_id_configured()`, then `return self.async_create_entry(title="Requestarr", data=self._data)`
- description_placeholders: `{"url_example": "http://192.168.1.50:8686"}`

**async_step_user(user_input):**
- Just redirect to radarr step: `return await self.async_step_radarr(user_input=None)`
- This is the entry point HA calls

**Helper function `_validate_and_fetch(self, service_type, url, api_key, verify_ssl)`:**
- Create ArrClient, validate, fetch profiles/folders (and metadata profiles for lidarr)
- Return dict of fetched data
- Raise CannotConnectError or InvalidAuthError on failure
- This avoids code duplication across the three step methods

**Class: RequestarrOptionsFlowHandler(OptionsFlow):**
- `async_step_init(user_input)`: Show dropdowns for quality profile and root folder per configured service, plus metadata profile for Lidarr, plus verify_ssl toggle per service
- Use `SelectSelector` with `SelectSelectorConfig(options=[...])` for dropdowns — build options list from stored profiles/folders in config entry data
- Include a "Refresh profiles" submit button (a boolean field `refresh_profiles` that when True triggers re-fetch of all profiles/folders from arr services and updates config entry data)
- On submit: update config entry data with new selections, reload entry

**Class: RequestarrReconfigureFlow — implement as async_step_reconfigure on the main ConfigFlow class:**
- `async_step_reconfigure(user_input)`: Re-run the 3-step wizard with current values pre-filled using `self.add_suggested_values_to_schema()`
- Only re-validate services whose URL or API key changed (compare with `self.config_entry.data`)
- On success: update config entry data and reload

**strings.json** — Complete rewrite with 3 arr service steps:

```json
{
  "config": {
    "step": {
      "radarr": {
        "title": "Radarr Configuration",
        "description": "Configure your Radarr server for movie management. Skip if you don't use Radarr.",
        "data": {
          "radarr_url": "Radarr URL",
          "radarr_api_key": "API Key",
          "radarr_verify_ssl": "Verify SSL certificate",
          "skip_radarr": "I don't use Radarr"
        },
        "data_description": {
          "radarr_url": "Base URL of your Radarr instance (e.g., {url_example})"
        }
      },
      "sonarr": {
        "title": "Sonarr Configuration",
        "description": "Configure your Sonarr server for TV series management. Skip if you don't use Sonarr.",
        "data": {
          "sonarr_url": "Sonarr URL",
          "sonarr_api_key": "API Key",
          "sonarr_verify_ssl": "Verify SSL certificate",
          "skip_sonarr": "I don't use Sonarr"
        },
        "data_description": {
          "sonarr_url": "Base URL of your Sonarr instance (e.g., {url_example})"
        }
      },
      "lidarr": {
        "title": "Lidarr Configuration",
        "description": "Configure your Lidarr server for music management. Skip if you don't use Lidarr.",
        "data": {
          "lidarr_url": "Lidarr URL",
          "lidarr_api_key": "API Key",
          "lidarr_verify_ssl": "Verify SSL certificate",
          "skip_lidarr": "I don't use Lidarr"
        },
        "data_description": {
          "lidarr_url": "Base URL of your Lidarr instance (e.g., {url_example})"
        }
      }
    },
    "error": {
      "cannot_connect": "Unable to connect. Check the URL and ensure the service is running.",
      "invalid_auth": "Invalid API key. Check your API key in the service settings.",
      "cannot_fetch_profiles": "Connected but could not fetch profiles. Check API key permissions.",
      "no_services": "At least one service must be configured.",
      "unknown": "An unexpected error occurred."
    },
    "abort": {
      "already_configured": "Requestarr is already configured."
    }
  },
  "options": {
    "step": {
      "init": {
        "title": "Requestarr Settings",
        "description": "Adjust quality profiles, root folders, and SSL settings. Enable 'Refresh profiles' to re-fetch options from your arr services.",
        "data": {
          "radarr_quality_profile_id": "Radarr Quality Profile",
          "radarr_root_folder": "Radarr Root Folder",
          "radarr_verify_ssl": "Radarr: Verify SSL",
          "sonarr_quality_profile_id": "Sonarr Quality Profile",
          "sonarr_root_folder": "Sonarr Root Folder",
          "sonarr_verify_ssl": "Sonarr: Verify SSL",
          "lidarr_quality_profile_id": "Lidarr Quality Profile",
          "lidarr_root_folder": "Lidarr Root Folder",
          "lidarr_metadata_profile_id": "Lidarr Metadata Profile",
          "lidarr_verify_ssl": "Lidarr: Verify SSL",
          "refresh_profiles": "Refresh profiles from services"
        }
      }
    },
    "error": {
      "cannot_connect": "Unable to connect to service.",
      "invalid_auth": "Invalid API key.",
      "unknown": "An unexpected error occurred."
    }
  }
}
```

**translations/en.json** — Must be an exact copy of strings.json. Copy the file byte-for-byte.

Important implementation notes:
- Use `async_get_clientsession(self.hass)` for all HTTP calls in the config flow — never create a new session
- The config flow class MUST be named `RequestarrConfigFlow` (not `TemplateConfigFlow`)
- Import `ArrClient` from `.api`, not `ApiClient`
- For the options flow, only show fields for services that are actually configured (check if URL exists in config entry data)
- The reconfigure flow is implemented as `async_step_reconfigure` on the main ConfigFlow class, not a separate class
  </action>
  <verify>
    <automated>cd /home/dab/Projects/ha-requestarr && python3 -c "from custom_components.requestarr.config_flow import RequestarrConfigFlow; print('ConfigFlow OK')" && python3 -c "import json; j=json.load(open('custom_components/requestarr/strings.json')); assert 'radarr' in j['config']['step']; assert 'sonarr' in j['config']['step']; assert 'lidarr' in j['config']['step']; print('strings.json OK')" && python3 -c "import json; s=json.load(open('custom_components/requestarr/strings.json')); t=json.load(open('custom_components/requestarr/translations/en.json')); assert s == t; print('translations match OK')"</automated>
  </verify>
  <done>
- Config flow has 3 steps: radarr -> sonarr -> lidarr
- Each step validates connection via ArrClient.async_validate_connection()
- Each step fetches quality profiles and root folders on successful validation
- Lidarr step also fetches metadata profiles
- Skip checkbox allows skipping any service
- Last step (lidarr) enforces at least one service configured
- Unique_id set to DOMAIN (singleton)
- Options flow shows profile/folder dropdowns for configured services only
- Options flow has refresh_profiles button to re-fetch from arr services
- Reconfigure flow re-runs wizard with current values pre-filled
- strings.json and en.json are identical and have all step/error/abort keys
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire coordinator with partial failure tolerance and update __init__.py</name>
  <files>custom_components/requestarr/coordinator.py, custom_components/requestarr/__init__.py</files>
  <action>
**coordinator.py** — Complete rewrite:

**Class: RequestarrCoordinator(DataUpdateCoordinator[dict[str, Any]]):**

Constructor `__init__(self, hass, entry)`:
- Call `super().__init__(hass, _LOGGER, name=DOMAIN, update_interval=timedelta(seconds=DEFAULT_SCAN_INTERVAL))` where DEFAULT_SCAN_INTERVAL = 300 (5 minutes)
- Store `self.config_entry = entry`
- Get shared session: `session = async_get_clientsession(hass)`
- Build `self._clients: dict[str, ArrClient]` — for each service type in `("radarr", "sonarr", "lidarr")`, check if `{service_type}_url` exists in `entry.data`. If it does, create an ArrClient instance with the URL, API key, service type, session, and verify_ssl from entry data.

Method `_async_update_data(self) -> dict[str, Any]`:
- Initialize `data = {}` and `errors = {}`
- For each `(service_type, client)` in `self._clients.items()`:
  - Try `count = await client.async_get_library_count()`
  - On success: `data[f"{service_type}_count"] = count`
  - On CannotConnectError or InvalidAuthError: log warning, `errors[service_type] = str(err)`, `data[f"{service_type}_count"] = None`
- After all services polled:
  - If ALL counts are None (every service failed): `raise UpdateFailed(f"All arr services are unavailable: {errors}")`
  - Otherwise: `data["errors"] = errors` and return data
- This implements partial failure tolerance: if Radarr is down but Sonarr is up, Sonarr's count still updates

Property `configured_services(self) -> list[str]`:
- Return list of service types that have clients: `list(self._clients.keys())`

**__init__.py** — Update to use RequestarrCoordinator:

Keep the existing structure but make these changes:
- Import `RequestarrCoordinator` instead of `TemplateCoordinator`
- Update the `RequestarrData` dataclass to store coordinator typed as `RequestarrCoordinator`
- In `async_setup_entry`:
  - Create `RequestarrCoordinator(hass, entry)`
  - Call `await coordinator.async_config_entry_first_refresh()`
  - Set `entry.runtime_data = RequestarrData(coordinator=coordinator)`
  - Forward entry setups for PLATFORMS
- Keep `async_setup()` exactly as-is (static path registration, websocket setup, services)
- Keep `async_unload_entry()` exactly as-is
- Keep `_async_register_lovelace_resource()` exactly as-is
- Keep PLATFORMS, CONFIG_SCHEMA, and RequestarrConfigEntry type alias as-is

Important notes:
- Do NOT change anything related to frontend static path registration — it's already correct
- Do NOT change websocket or service registration — those are for later phases
- Do NOT change PLATFORMS — sensor.py and binary_sensor.py still exist and will be customized in Phase 2
- The coordinator will return `None` counts for services that fail, which sensors in Phase 2 will use to mark themselves unavailable
  </action>
  <verify>
    <automated>cd /home/dab/Projects/ha-requestarr && python3 -c "from custom_components.requestarr.coordinator import RequestarrCoordinator; from custom_components.requestarr.__init__ import RequestarrData; print('OK')"</automated>
  </verify>
  <done>
- coordinator.py defines RequestarrCoordinator with partial failure tolerance
- Coordinator creates ArrClient instances for each configured service
- _async_update_data polls all configured services, handles individual failures
- Raises UpdateFailed only if ALL services fail
- __init__.py creates RequestarrCoordinator and stores in runtime_data
- All existing __init__.py functionality preserved (static paths, websocket, services)
- Polling interval is 5 minutes (300 seconds)
  </done>
</task>

</tasks>

<verification>
After all tasks complete, verify the integration loads:
1. `python3 -c "from custom_components.requestarr.const import DOMAIN, ARR_SERVICES, API_VERSIONS"` — constants importable
2. `python3 -c "from custom_components.requestarr.api import ArrClient, CannotConnectError, InvalidAuthError"` — API client importable
3. `python3 -c "from custom_components.requestarr.config_flow import RequestarrConfigFlow"` — config flow importable
4. `python3 -c "from custom_components.requestarr.coordinator import RequestarrCoordinator"` — coordinator importable
5. `python3 -c "from custom_components.requestarr import RequestarrData"` — init module importable
6. Verify strings.json and en.json are valid JSON and identical
7. Verify all config flow step IDs (radarr, sonarr, lidarr) exist in strings.json
</verification>

<success_criteria>
- Config flow validates each arr service connection with live API call to /system/status
- Each arr service can be independently skipped; at least one must be configured
- Quality profiles, root folders, and metadata profiles (Lidarr) fetched and stored in config entry
- Coordinator polls library counts every 5 minutes with partial failure tolerance
- Options flow allows changing profiles/folders and refreshing from services
- Reconfigure flow re-runs wizard with current values pre-filled
- strings.json and en.json are valid and in sync
- No TMDB key step — arr services are the only external dependency
</success_criteria>

<output>
After completion, create `.planning/phases/01-config-flow-api-clients/01-01-SUMMARY.md`
</output>
